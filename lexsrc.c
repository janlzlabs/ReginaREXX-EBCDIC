#line 2 "./lexsrc.c"

#line 4 "./lexsrc.c"

#define  YY_INT_ALIGNED short int

/* A lexical scanner generated by flex */

#define yy_create_buffer __regina_create_buffer
#define yy_delete_buffer __regina_delete_buffer
#define yy_flex_debug __regina_flex_debug
#define yy_init_buffer __regina_init_buffer
#define yy_flush_buffer __regina_flush_buffer
#define yy_load_buffer_state __regina_load_buffer_state
#define yy_switch_to_buffer __regina_switch_to_buffer
#define yyin __reginain
#define yyleng __reginaleng
#define yylex __reginalex
#define yylineno __reginalineno
#define yyout __reginaout
#define yyrestart __reginarestart
#define yytext __reginatext
#define yywrap __reginawrap
#define yyalloc __reginaalloc
#define yyrealloc __reginarealloc
#define yyfree __reginafree

#define FLEX_SCANNER
#define YY_FLEX_MAJOR_VERSION FLEX_MAJOR_VERSION
#define YY_FLEX_MINOR_VERSION FLEX_MINOR_VERSION
#define YY_FLEX_SUBMINOR_VERSION FLEX_SUBMINOR_VERSION
#if YY_FLEX_SUBMINOR_VERSION > 0
#define FLEX_BETA
#endif

/* First, we deal with  platform-specific or compiler-specific issues. */

/* begin standard C headers. */
#include <stdio.h>
#include <string.h>
#include <errno.h>
#include <stdlib.h>
#include "flexint.h"

/* end standard C headers. */

#ifdef __cplusplus

/* The "const" storage-class-modifier is valid. */
#define YY_USE_CONST

#else	/* ! __cplusplus */

/* C99 requires __STDC__ to be defined as 1. */
#if defined (__STDC__)

#define YY_USE_CONST

#endif	/* defined (__STDC__) */
#endif	/* ! __cplusplus */

#ifdef YY_USE_CONST
#define yyconst const
#else
#define yyconst
#endif

/* Returned upon end-of-file. */
#define YY_NULL 0

/* Promotes a possibly negative, possibly signed char to an unsigned
 * integer for use as an array index.  If the signed char is negative,
 * we want to instead treat it as an 8-bit unsigned char, hence the
 * double cast.
 */
#define YY_SC_TO_UI(c) ((unsigned int) (unsigned char) c)

/* Enter a start condition.  This macro really ought to take a parameter,
 * but we do it the disgusting crufty way forced on us by the ()-less
 * definition of BEGIN.
 */
#define BEGIN (yy_start) = 1 + 2 *

/* Translate the current start state into a value that can be later handed
 * to BEGIN to return to the state.  The YYSTATE alias is for lex
 * compatibility.
 */
#define YY_START (((yy_start) - 1) / 2)
#define YYSTATE YY_START

/* Action number for EOF rule of a given start state. */
#define YY_STATE_EOF(state) (YY_END_OF_BUFFER + state + 1)

/* Special action meaning "start processing a new file". */
#define YY_NEW_FILE yyrestart( yyin  )

#define YY_END_OF_BUFFER_CHAR 0

/* Size of default input buffer. */
#ifndef YY_BUF_SIZE
#ifdef __ia64__
/* On IA-64, the buffer size is 16k, not 8k.
 * Moreover, YY_BUF_SIZE is 2*YY_READ_BUF_SIZE in the general case.
 * Ditto for the __ia64__ case accordingly.
 */
#define YY_BUF_SIZE 32768
#else
#define YY_BUF_SIZE 16384
#endif /* __ia64__ */
#endif

/* The state buf must be large enough to hold one state per character in the main buffer.
 */
#define YY_STATE_BUF_SIZE   ((YY_BUF_SIZE + 2) * sizeof(yy_state_type))

#ifndef YY_TYPEDEF_YY_BUFFER_STATE
#define YY_TYPEDEF_YY_BUFFER_STATE
typedef struct yy_buffer_state *YY_BUFFER_STATE;
#endif

#ifndef YY_TYPEDEF_YY_SIZE_T
#define YY_TYPEDEF_YY_SIZE_T
typedef size_t yy_size_t;
#endif

extern yy_size_t yyleng;

extern FILE *yyin, *yyout;
extern FILE *yyin_io, *yyout_io;

#define EOB_ACT_CONTINUE_SCAN 0
#define EOB_ACT_END_OF_FILE 1
#define EOB_ACT_LAST_MATCH 2

    #define YY_LESS_LINENO(n)
    #define YY_LINENO_REWIND_TO(ptr)
    
/* Return all but the first "n" matched characters back to the input stream. */
#define yyless(n) \
	do \
		{ \
		/* Undo effects of setting up yytext. */ \
        int yyless_macro_arg = (n); \
        YY_LESS_LINENO(yyless_macro_arg);\
		*yy_cp = (yy_hold_char); \
		YY_RESTORE_YY_MORE_OFFSET \
		(yy_c_buf_p) = yy_cp = yy_bp + yyless_macro_arg - YY_MORE_ADJ; \
		YY_DO_BEFORE_ACTION; /* set up yytext again */ \
		} \
	while ( 0 )

#define unput(c) yyunput( c, (yytext_ptr)  )

#ifndef YY_STRUCT_YY_BUFFER_STATE
#define YY_STRUCT_YY_BUFFER_STATE
struct yy_buffer_state
	{
	FILE *yy_input_file;

	char *yy_ch_buf;		/* input buffer */
	char *yy_buf_pos;		/* current position in input buffer */

	/* Size of input buffer in bytes, not including room for EOB
	 * characters.
	 */
	yy_size_t yy_buf_size;

	/* Number of characters read into yy_ch_buf, not including EOB
	 * characters.
	 */
	yy_size_t yy_n_chars;

	/* Whether we "own" the buffer - i.e., we know we created it,
	 * and can realloc() it to grow it, and should free() it to
	 * delete it.
	 */
	int yy_is_our_buffer;

	/* Whether this is an "interactive" input source; if so, and
	 * if we're using stdio for input, then we want to use getc()
	 * instead of fread(), to make sure we stop fetching input after
	 * each newline.
	 */
	int yy_is_interactive;

	/* Whether we're considered to be at the beginning of a line.
	 * If so, '^' rules will be active on the next match, otherwise
	 * not.
	 */
	int yy_at_bol;

    int yy_bs_lineno; /**< The line count. */
    int yy_bs_column; /**< The column count. */
    
	/* Whether to try to fill the input buffer when we reach the
	 * end of it.
	 */
	int yy_fill_buffer;

	int yy_buffer_status;

#define YY_BUFFER_NEW 0
#define YY_BUFFER_NORMAL 1
	/* When an EOF's been seen but there's still some text to process
	 * then we mark the buffer as YY_EOF_PENDING, to indicate that we
	 * shouldn't try reading from the input source any more.  We might
	 * still have a bunch of tokens to match, though, because of
	 * possible backing-up.
	 *
	 * When we actually see the EOF, we change the status to "new"
	 * (via yyrestart()), so that the user can continue scanning by
	 * just pointing yyin at a new input file.
	 */
#define YY_BUFFER_EOF_PENDING 2

	};
#endif /* !YY_STRUCT_YY_BUFFER_STATE */

/* Stack of input buffers. */
static size_t yy_buffer_stack_top = 0; /**< index of top of stack. */
static size_t yy_buffer_stack_max = 0; /**< capacity of stack. */
static YY_BUFFER_STATE * yy_buffer_stack = 0; /**< Stack as an array. */

/* We provide macros for accessing buffer states in case in the
 * future we want to put the buffer states in a more general
 * "scanner state".
 *
 * Returns the top of the stack, or NULL.
 */
#define YY_CURRENT_BUFFER ( (yy_buffer_stack) \
                          ? (yy_buffer_stack)[(yy_buffer_stack_top)] \
                          : NULL)

/* Same as previous macro, but useful when we know that the buffer stack is not
 * NULL or when we need an lvalue. For internal use only.
 */
#define YY_CURRENT_BUFFER_LVALUE (yy_buffer_stack)[(yy_buffer_stack_top)]

/* yy_hold_char holds the character lost when yytext is formed. */
static char yy_hold_char;
static yy_size_t yy_n_chars;		/* number of characters read into yy_ch_buf */
yy_size_t yyleng;

/* Points to current character in buffer. */
static char *yy_c_buf_p = (char *) 0;
static int yy_init = 0;		/* whether we need to initialize */
static int yy_start = 0;	/* start state number */

/* Flag which is used to allow yywrap()'s to do buffer switches
 * instead of setting up a fresh yyin.  A bit of a hack ...
 */
static int yy_did_buffer_switch_on_eof;

void yyrestart (FILE *input_file  );
void yy_switch_to_buffer (YY_BUFFER_STATE new_buffer  );
YY_BUFFER_STATE yy_create_buffer (FILE *file,int size  );
void yy_delete_buffer (YY_BUFFER_STATE b  );
void yy_flush_buffer (YY_BUFFER_STATE b  );
void yypush_buffer_state (YY_BUFFER_STATE new_buffer  );
void yypop_buffer_state (void );

static void yyensure_buffer_stack (void );
static void yy_load_buffer_state (void );
static void yy_init_buffer (YY_BUFFER_STATE b,FILE *file  );

#define YY_FLUSH_BUFFER yy_flush_buffer( YY_CURRENT_BUFFER )

YY_BUFFER_STATE yy_scan_buffer (char *base,yy_size_t size  );
YY_BUFFER_STATE yy_scan_string (yyconst char *yy_str  );
YY_BUFFER_STATE yy_scan_bytes (yyconst char *bytes,yy_size_t len  );

void *yyalloc (yy_size_t  );
void *yyrealloc (void *,yy_size_t  );
void yyfree (void *  );

#define yy_new_buffer yy_create_buffer

#define yy_set_interactive(is_interactive) \
	{ \
	if ( ! YY_CURRENT_BUFFER ){ \
        yyensure_buffer_stack (); \
		YY_CURRENT_BUFFER_LVALUE =    \
            yy_create_buffer( yyin, YY_BUF_SIZE ); \
	} \
	YY_CURRENT_BUFFER_LVALUE->yy_is_interactive = is_interactive; \
	}

#define yy_set_bol(at_bol) \
	{ \
	if ( ! YY_CURRENT_BUFFER ){\
        yyensure_buffer_stack (); \
		YY_CURRENT_BUFFER_LVALUE =    \
            yy_create_buffer( yyin, YY_BUF_SIZE ); \
	} \
	YY_CURRENT_BUFFER_LVALUE->yy_at_bol = at_bol; \
	}

#define YY_AT_BOL() (YY_CURRENT_BUFFER_LVALUE->yy_at_bol)

/* Begin user sect3 */

typedef unsigned char YY_CHAR;

FILE *yyin = (FILE *) 0, *yyout = (FILE *) 0;

typedef int yy_state_type;

extern int yylineno;

int yylineno = 1;

extern char *yytext;
#ifdef yytext_ptr
#undef yytext_ptr
#endif
#define yytext_ptr yytext

static yy_state_type yy_get_previous_state (void );
static yy_state_type yy_try_NUL_trans (yy_state_type current_state  );
static int yy_get_next_buffer (void );
#if defined(__GNUC__) && __GNUC__ >= 3
__attribute__((__noreturn__))
#endif
static void yy_fatal_error (yyconst char msg[]  );

/* Done after the current pattern has been matched and before the
 * corresponding action - sets up yytext.
 */
#define YY_DO_BEFORE_ACTION \
	(yytext_ptr) = yy_bp; \
	yyleng = (size_t) (yy_cp - yy_bp); \
	(yy_hold_char) = *yy_cp; \
	*yy_cp = '\0'; \
	(yy_c_buf_p) = yy_cp;

#define YY_NUM_RULES 145
#define YY_END_OF_BUFFER 146
/* This struct is not used in this scanner,
   but its presence is necessary. */
struct yy_trans_info
	{
	flex_int32_t yy_verify;
	flex_int32_t yy_nxt;
	};
static yyconst flex_int16_t yy_acclist[1369] =
    {   0,
        1,   33,    1,   33,    1,   33,    1,   33,    1,   33,
        1,   33,    1,   33,    1,   33,    1,   33,    1,   33,
        1,   33,    1,   33,    1,   33,    1,   33,    1,   33,
        1,   33,    1,   33,    1,   33,    1,   33,    1,   33,
        1,   33,    1,   33,    1,   33,    1,   33,    1,   33,
        1,   33,    1,   33,    1,   33,    1,   33,    1,   33,
      146,  144,  145,   33,  141,  144,  145,    3,  145,   33,
      141,  144,  145,  110,  144,  145,  142,  144,  145,  118,
      144,  145,  121,  144,  145,  142,  144,  145,  113,  144,
      145,  112,  144,  145,  119,  144,  145,  116,  144,  145,

      114,  144,  145,  115,  144,  145,   34,  109,  144,  145,
      117,  144,  145,  106,  109,  144,  145,  143,  144,  145,
        3,  144,  145,  132,  144,  145,  122,  144,  145,  130,
      144,  145,  110,  144,  145,  110,  144,  145,  110,  144,
      145,  110,  144,  145,  110,  144,  145,  123,  144,  145,
        1,   33,  144,  145,  120,  144,  145,   33,  141,  144,
      145,   33,  141,  144,  145,  110,  144,  145,  142,  144,
      145,  142,  144,  145,   34,  109,  144,  145,  106,  109,
      144,  145,  110,  144,  145,  110,  144,  145,  110,  144,
      145,  110,  144,  145,  110,  144,  145,  110,  144,  145,

      110,  144,  145,  110,  144,  145,  110,  144,  145,  110,
      144,  145,  110,  144,  145,  110,  144,  145,  110,  144,
      145,  110,  144,  145,  110,  144,  145,  110,  144,  145,
      110,  144,  145,    1,   33,  144,  145,   33,  141,  144,
      145,   33,  141,  144,  145,  110,  144,  145,  110,  144,
      145,    1,   33,  144,  145,  110,  144,  145,  110,  144,
      145,  110,  144,  145,  110,  144,  145,  110,  144,  145,
      110,  144,  145,  110,  144,  145,  110,  144,  145,  110,
      144,  145,  110,  144,  145,  110,  144,  145,  110,  144,
      145,  110,  144,  145,  110,  144,  145,  110,  144,  145,

      110,  144,  145,  110,  144,  145,  110,  144,  145,  110,
      144,  145,  110,  144,  145,   34,  109,  144,  145,  110,
      144,  145,  110,  144,  145,  110,  144,  145,  110,  144,
      145,  110,  144,  145,   33,  141,  144,  145,   33,  141,
      144,  145,  110,  144,  145,    1,   33,  144,  145,   33,
      141,  144,  145,   33,  141,  144,  145,   68,  110,  144,
      145,   34,   68,  109,  144,  145,   68,  106,  109,  144,
      145,   68,  110,  144,  145,   68,  110,  144,  145,   68,
      110,  144,  145,   68,  110,  144,  145,   68,  110,  144,
      145,   68,  110,  144,  145,    1,   33,  144,  145,   33,

      141,  144,  145,    2,    3,  145,   33,  141,  144,  145,
        2,    3,  144,  145,    1,   33,  144,  145,  110,  144,
      145,  110,  144,  145,  110,  144,  145,   33,  141,    3,
       33,  141,  118,  121,  112,  119,  116,  114,  115,  117,
      132,  122,  130,   33,  141,  120,    3,  110,  110,  105,
      118,  121,  138,  121,  105,  113,  119,  140,  119,  116,
      114,  115,  109,  109,  109,  109,  111,  109,  111,  117,
      137,  117,  107,  108,  109,  106,  109,  109,  132,  125,
      133,  134,  132,  122,  135,  131,  122,  130,  124,  130,
       93,  110,  110,   92,  110,  110,  110,  110,  123,  131,

      134,  133,  123,   33,  141,   33,  141,    1,   33,  120,
      120,  139,   33,  141,   33,  141,   33,  141,  110,  110,
       99,   36,  105,  105,  109,  109,  109,   35,  109,  111,
      109,  111,  107,  108,  107,  108,  107,  108,  107,  108,
      107,  108,  107,  108,  109,  107,  108,  106,  109,   99,
      107,  108,   35,  107,  108,  109,  107,  108,  110,  110,
       93,  110,  110,    8,  110,  110,  110,  110,  110,  110,
       12,  110,  110,  110,  110,  110,  110,  110,  110,  110,
      110,  110,  110,  110,  110,  110,  110,  110,   92,  110,
      110,  110,  110,  110,  110,   33,  141,   33,  141,    1,

       33,   33,  141,   33,  141,   33,  141,  110,   58,  110,
      110,   33,  141,   33,  141,    1,   33,  110,  110,  110,
      110,  110,  110,  110,  110,  110,  110,  110,  110,  110,
      110,  110,  110,  110,  110,  110,  110,  110,  110,  110,
      110,   98,  109,  111,  109,  111,   93,  110,  110,   92,
      110,  110,  110,  110,   33,  141,   33,  141,   33,  141,
      110,   33,  141,   33,  141,    1,   33,   33,  141,   33,
      141,   68,   68,   68,   68,   33,  141,   68,   68,  110,
       68,  110,   68,  109,   68,  109,   68,  109,   68,  109,
      111,   68,  109,  111,   68,  107,  108,   68,  109,   68,

      106,  109,   68,  109,   68,   93,  110,   68,  110,   68,
       92,  110,   68,  110,   68,  110,   68,  110,   68,  110,
       33,  141,   33,  141,    1,   33,   33,  141,    2,    3,
       33,  141,   33,  141,    2,    3,   33,  141,   33,  141,
        1,   33,  110,  110,  110,  105,  105,  105,  138,  105,
      105,  105,  140,  108,  109,  111,  137,  109,  109,  125,
      129,  125,  133,  134,  135,  131,  124,  128,  124,   93,
       94,  110,   92,  110,  110,  110,  131,  127,  130,  134,
      136,  132,  133,  126,  139,   46,   52,   42,   38,   40,
       44,   99,   36,   50,  105,  105,  105,  105,  105,  105,

       45,   51,   41,   37,   39,   43,  108,  108,  108,  108,
      108,  108,  108,   99,  108,   35,  108,  108,   35,  109,
      111,   49,  109,  109,  110,    6,  110,   93,  110,    8,
      110,  110,   32,  110,  110,   94,  110,   12,  110,  110,
      110,   17,  110,  110,  110,  110,  110,  110,  110,  110,
      110,  110,   25,  110,  110,  110,  110,   92,  110,  110,
      110,  110,  110,  110,   59,  110,   58,  110,  110,  110,
      110,  110,  110,  110,  110,  110,   73,  110,  110,  110,
      110,  110,  110,  110,  110,  110,  110,  110,   81,  110,
      110,  110,   94,  110,  110,   97,  109,  111,   93,   94,

      110,   92,  110,  110,  110,  110,   68,   68,   68,   68,
       68,   68,   68,  110,   68,  110,   68,  109,   68,  109,
       68,  108,   68,  109,  111,   68,  109,  111,   68,  109,
       68,  109,   68,   93,   68,   94,  110,   68,   92,   68,
      110,   68,  110,   68,  110,   68,  110,  110,  110,  110,
      101,  103,  104,  103,  102,  104,  102,  109,  111,  129,
      128,   94,  110,  110,   85,  110,  127,  136,  126,   46,
       54,   52,   42,   38,   40,   48,   44,   50,   56,  100,
       45,   53,   51,   41,   37,   39,   47,   43,  109,  111,
       49,   55,  110,    6,    7,  110,    9,  110,   10,  110,

       32,   11,  110,   94,  110,  110,  110,   17,  110,  110,
      110,  110,  110,   21,  110,   22,  110,  110,  110,   25,
      110,  110,   83,  110,  110,  110,  110,   30,  110,  110,
       85,  110,   59,  110,  110,  110,   62,  110,  110,  110,
      110,  110,  110,   73,  110,  110,  110,  110,  110,  110,
       75,  110,  110,  110,  110,   81,  110,  110,   87,  110,
       90,  110,  109,  111,   94,  110,  110,  110,   85,  110,
       84,  110,   68,   68,   68,   68,   68,  109,  111,   68,
       94,   68,  110,   68,  110,   68,  110,   68,   85,  110,
       60,  110,  110,  110,   85,  104,  109,  111,   96,  110,

       95,  110,   85,   83,   54,   48,   56,  100,   53,   47,
      109,  111,   55,  110,    7,    9,   10,   11,  110,  110,
       15,  110,  110,  110,  110,   19,  110,  110,   21,   22,
       23,  110,  110,  110,  110,   83,   28,  110,   96,  110,
       29,  110,   30,   95,  110,   85,   57,  110,   61,  110,
      110,   62,  110,  110,  110,  110,  110,  110,  110,  110,
      110,   71,  110,  110,   75,  110,   70,  110,   82,  110,
      110,  110,   87,   90,  109,  111,  110,   96,  110,   95,
      110,   85,   84,   84,   68,   68,   85,   68,  109,  111,
       68,   96,  110,   57,   68,  110,   68,   95,  110,   68,

       85,   60,  110,  110,    4,   96,   95,   83,    4,    4,
        4,    4,    4,    4,    4,    4,   99,    4,   35,    4,
      110,  110,  110,   15,  110,  110,  110,   19,  110,   23,
       24,  110,   26,  110,   27,  110,   28,   96,   29,   95,
       57,   57,   61,  110,  110,  110,  110,   66,  110,   69,
      110,  110,  110,  110,   78,  110,   71,  110,   76,  110,
       70,   82,  110,   86,  110,    4,    4,   97,  110,   96,
       95,   57,   68,    4,   68,   68,   96,   57,   68,   68,
       95,  110,  110,    5,  110,  110,   14,  110,   18,  110,
       16,  110,  110,  110,   24,   26,   27,   65,  110,  110,

      110,   63,  110,   66,   69,  110,  110,  110,   78,   74,
      110,   76,   79,  110,   86,   91,  110,  110,  110,    5,
      110,   14,   18,   16,  110,  110,   65,  110,   64,  110,
       63,   72,  110,   77,  110,   80,  110,   74,   79,   91,
      110,  110,   13,  110,   31,  110,   20,  110,  110,   64,
       72,   77,   80,  110,  110,   13,   31,   20,   67,  110,
      110,   88,  110,   67,   89,  110,   88,   89
    } ;

static yyconst flex_int16_t yy_accept[1002] =
    {   0,
        1,    3,    5,    7,    9,   11,   13,   15,   17,   19,
       21,   23,   25,   27,   29,   31,   33,   35,   37,   39,
       41,   43,   45,   47,   49,   51,   53,   55,   57,   59,
       61,   62,   64,   68,   70,   74,   77,   80,   83,   86,
       89,   92,   95,   98,  101,  104,  107,  111,  114,  118,
      121,  124,  127,  130,  133,  136,  139,  142,  145,  148,
      151,  155,  158,  162,  166,  169,  172,  175,  179,  183,
      186,  189,  192,  195,  198,  201,  204,  207,  210,  213,
      216,  219,  222,  225,  228,  231,  234,  238,  242,  246,
      249,  252,  256,  259,  262,  265,  268,  271,  274,  277,

      280,  283,  286,  289,  292,  295,  298,  301,  304,  307,
      310,  313,  316,  320,  323,  326,  329,  332,  335,  339,
      343,  346,  350,  354,  358,  362,  367,  372,  376,  380,
      384,  388,  392,  396,  400,  404,  407,  411,  415,  419,
      422,  425,  428,  430,  431,  433,  434,  435,  436,  437,
      438,  439,  440,  441,  442,  443,  444,  444,  444,  446,
      447,  448,  449,  450,  450,  451,  451,  451,  452,  453,
      454,  455,  455,  456,  456,  456,  457,  458,  459,  460,
      461,  462,  463,  464,  465,  466,  468,  470,  471,  472,
      473,  475,  476,  478,  479,  480,  481,  482,  483,  484,

      485,  486,  487,  488,  489,  490,  491,  493,  494,  496,
      497,  498,  499,  500,  501,  502,  503,  504,  506,  508,
      510,  511,  512,  513,  515,  517,  517,  519,  519,  520,
      520,  520,  520,  520,  520,  521,  521,  522,  523,  523,
      523,  524,  524,  524,  524,  525,  525,  525,  525,  526,
      526,  526,  526,  526,  526,  527,  527,  528,  529,  531,
      533,  533,  535,  537,  539,  541,  543,  545,  546,  548,
      550,  553,  556,  557,  559,  560,  561,  563,  564,  566,
      567,  568,  569,  570,  571,  573,  574,  575,  576,  577,
      578,  579,  580,  581,  582,  583,  584,  585,  586,  587,

      588,  589,  591,  592,  593,  594,  595,  596,  598,  600,
      602,  604,  606,  606,  608,  609,  611,  612,  614,  616,
      618,  619,  620,  621,  622,  623,  624,  625,  626,  627,
      628,  629,  630,  631,  632,  633,  634,  635,  636,  637,
      638,  639,  640,  640,  641,  642,  643,  645,  647,  649,
      650,  652,  653,  654,  655,  657,  659,  659,  661,  662,
      664,  666,  668,  670,  672,  673,  674,  675,  676,  678,
      679,  681,  683,  685,  687,  689,  692,  695,  698,  700,
      703,  705,  708,  710,  713,  715,  717,  719,  721,  723,
      725,  727,  729,  731,  733,  735,  737,  739,  741,  743,

      744,  745,  746,  746,  746,  747,  747,  747,  747,  748,
      748,  748,  748,  749,  750,  751,  751,  752,  752,  752,
      752,  753,  754,  755,  757,  758,  759,  759,  760,  761,
      762,  763,  764,  765,  766,  767,  768,  769,  770,  771,
      773,  774,  775,  776,  777,  778,  779,  780,  781,  782,
      783,  784,  785,  786,  786,  786,  787,  787,  787,  788,
      788,  789,  789,  790,  790,  791,  791,  791,  792,  793,
      794,  794,  795,  795,  796,  796,  797,  797,  797,  797,
      798,  799,  799,  800,  800,  800,  800,  801,  801,  802,
      802,  802,  803,  803,  804,  804,  805,  805,  806,  806,

      806,  807,  808,  809,  810,  811,  812,  813,  814,  816,
      818,  819,  820,  822,  822,  823,  823,  824,  824,  824,
      825,  826,  828,  829,  830,  831,  832,  833,  835,  836,
      838,  839,  840,  841,  842,  844,  845,  846,  847,  848,
      849,  850,  851,  852,  853,  855,  856,  857,  858,  859,
      860,  861,  862,  863,  864,  865,  865,  867,  868,  869,
      870,  871,  872,  873,  874,  875,  876,  877,  879,  880,
      881,  882,  883,  884,  885,  886,  887,  888,  889,  891,
      892,  893,  895,  896,  896,  897,  899,  900,  902,  903,
      904,  905,  906,  906,  907,  908,  909,  910,  911,  912,

      913,  915,  917,  919,  921,  923,  926,  929,  931,  933,
      935,  938,  940,  942,  944,  946,  948,  949,  950,  951,
      951,  952,  952,  952,  954,  955,  957,  958,  958,  958,
      958,  958,  958,  958,  958,  958,  960,  960,  961,  962,
      963,  964,  965,  967,  968,  969,  970,  970,  971,  971,
      972,  973,  974,  975,  976,  976,  977,  978,  979,  979,
      980,  980,  981,  981,  981,  981,  981,  981,  981,  981,
      981,  981,  982,  982,  983,  984,  985,  986,  987,  987,
      988,  989,  991,  992,  992,  993,  994,  995,  997,  999,
     1001, 1002, 1004, 1005, 1006, 1007, 1008, 1009, 1010, 1011,

     1012, 1013, 1014, 1016, 1018, 1019, 1020, 1021, 1022, 1023,
     1025, 1026, 1027, 1028, 1030, 1031, 1033, 1033, 1034, 1035,
     1036, 1037, 1039, 1040, 1041, 1042, 1043, 1044, 1045, 1046,
     1047, 1048, 1049, 1050, 1051, 1053, 1054, 1055, 1056, 1057,
     1058, 1059, 1061, 1063, 1065, 1066, 1067, 1068, 1069, 1071,
     1071, 1073, 1074, 1075, 1076, 1077, 1080, 1082, 1084, 1086,
     1088, 1091, 1093, 1094, 1095, 1096, 1097, 1097, 1097, 1097,
     1097, 1097, 1097, 1099, 1101, 1103, 1104, 1105, 1106, 1107,
     1108, 1109, 1109, 1109, 1109, 1109, 1109, 1109, 1110, 1111,
     1113, 1114, 1115, 1116, 1117, 1118, 1119, 1120, 1121, 1123,

     1124, 1125, 1126, 1128, 1129, 1130, 1131, 1133, 1134, 1135,
     1136, 1137, 1139, 1141, 1143, 1144, 1146, 1147, 1147, 1149,
     1151, 1152, 1153, 1154, 1155, 1156, 1157, 1158, 1159, 1160,
     1161, 1162, 1164, 1165, 1166, 1167, 1169, 1171, 1172, 1173,
     1174, 1175, 1177, 1178, 1180, 1182, 1183, 1184, 1185, 1186,
     1188, 1191, 1194, 1197, 1200, 1202, 1203, 1204, 1205, 1205,
     1205, 1205, 1205, 1206, 1207, 1208, 1209, 1209, 1209, 1209,
     1209, 1210, 1211, 1212, 1213, 1214, 1215, 1216, 1218, 1220,
     1221, 1222, 1223, 1224, 1225, 1226, 1227, 1228, 1229, 1230,
     1231, 1233, 1235, 1237, 1238, 1239, 1240, 1241, 1242, 1243,

     1244, 1245, 1246, 1247, 1248, 1250, 1252, 1253, 1254, 1255,
     1257, 1258, 1259, 1261, 1262, 1263, 1264, 1266, 1267, 1269,
     1270, 1271, 1272, 1274, 1276, 1278, 1280, 1282, 1283, 1284,
     1284, 1284, 1284, 1284, 1286, 1287, 1289, 1291, 1293, 1294,
     1295, 1296, 1297, 1298, 1300, 1301, 1302, 1304, 1305, 1306,
     1307, 1308, 1309, 1310, 1312, 1313, 1315, 1316, 1318, 1319,
     1320, 1321, 1322, 1323, 1324, 1325, 1326, 1327, 1328, 1329,
     1331, 1332, 1334, 1336, 1338, 1339, 1340, 1341, 1342, 1343,
     1345, 1347, 1349, 1350, 1351, 1352, 1353, 1354, 1355, 1356,
     1357, 1358, 1359, 1361, 1362, 1364, 1365, 1367, 1368, 1369,

     1369
    } ;

static yyconst YY_CHAR yy_ec[256] =
    {   0,
        1,    1,    1,    1,    1,    1,    1,    1,    2,    3,
        4,    4,    5,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    2,    6,    7,    8,    8,    9,   10,   11,   12,
       13,   14,   15,   16,   17,   18,   19,   20,   20,   21,
       21,   21,   21,   21,   21,   21,   21,   22,   23,   24,
       25,   26,    6,    8,   27,   28,   29,   30,   31,   32,
       33,   34,   35,   36,   36,   37,   38,   39,   40,   41,
       42,   43,   44,   45,   46,   47,   48,   49,   50,   51,
        1,   52,    1,   52,    6,   53,   27,   28,   29,   30,

       31,   32,   33,   34,   35,   36,   36,   37,   38,   39,
       40,   41,   42,   43,   44,   45,   46,   47,   48,   49,
       50,   51,    1,   54,    1,   52,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,   52,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,   52,    1,
       52,    1,    1,   52,    1,    1,    1,    1,    1,    1,

        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,   52,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1
    } ;

static yyconst YY_CHAR yy_meta[55] =
    {   0,
        1,    2,    1,    2,    2,    3,    1,    3,    4,    4,
        1,    5,    1,    4,    4,    1,    4,    3,    4,    6,
        6,    4,    1,    1,    7,    1,    3,    3,    3,    3,
        3,    3,    3,    3,    3,    3,    3,    3,    3,    3,
        3,    3,    3,    3,    3,    3,    3,    3,    3,    3,
        3,    1,    2,    4
    } ;

static yyconst flex_uint16_t yy_base[1046] =
    {   0,
        0,    0,   54,    0,  107,  111,   86,   90, 1898, 1883,
      138,  159,    0,    0,    0,    0,   96,  101,  206,    0,
      136,  148,  260,    0,  313,  317, 1861, 1854,  321,  325,
     1880, 6409,  377,  141,    0,  141,  425,  330,  344,  447,
      355, 6409,  359,  409,  413,  417,  443,  431,  484, 6409,
      537,  541,  545,  549,  152,  386,  419,  537,  543,  579,
      583,  587,  604,    0,  656,  704,  726,  757,  811,  864,
       89,  301,  307,  577,  345,  580,  105,  398,  133,  588,
      550,  125,  608,  587,  312,  594,  595,  640,    0,  662,
      632,  686,  677,  686,  694,  682,  698,  723,  731,  870,

      875,  879,  883,  890,  894,  901,  906,  709,  914,  918,
      930,  953,  946, 1005,  147,  293,  141,  612,  958,    0,
      959,  980, 1057,    0,  984, 1110, 1163,  996,  327,  349,
      345,   87,  629,  990, 1016, 1216,    0, 1220, 1224, 1011,
     1099, 1024,    0, 1228,    0, 1232, 1236, 6409, 1240, 1245,
     1251, 1255, 1259, 1266, 1270, 1301, 1836, 1119,    0, 1278,
     1282,  451, 1030, 1860,  916, 1353, 1130, 1295, 1311, 1334,
     1338, 1841,  155, 1390, 1137, 1345, 1361, 1374, 1384, 1395,
     1400, 1404, 1036, 1131, 1457, 1418, 1478, 1483, 1438, 1442,
     6409,  318,    0, 1138, 1499, 1503, 1447, 1488, 1510, 1514,

     1525, 1529, 1540, 1544, 1549, 1553, 1571, 1350, 1557, 1289,
     1395, 1411, 1575, 1579, 1583, 1609, 1613,    0,    0,    0,
     1617, 1621, 1625,    0,    0, 1803,    0, 1677,  114, 1635,
     1639, 1643, 1648, 1652,  380, 1693, 1699, 1703, 1709, 1820,
     1313, 1762, 1715, 1805,  432, 1793, 1721, 1824, 1877, 1734,
     1740, 1749, 1753, 1771, 1930, 1782, 1984, 1766, 2037, 1777,
     1806,    0, 1775, 1840, 1849, 1859, 1864,  427, 1899, 2091,
     1853, 1868,  855, 1903,  529,  656, 1911,  938, 2116,  837,
      624,  552,  926,  626, 2120,  738,  997, 1287,  890, 1205,
     1222,  662,  642, 1236, 1646, 1004, 1316, 1083, 1281, 1517,

     1685, 2124, 1326, 1420, 1382, 1805, 1492,    0,    0, 1907,
        0,    0, 1782,    0, 1728, 1915, 1905,    0,    0, 1961,
     1938, 1797, 1953, 1958, 2003, 2010, 1999, 1949, 2112, 1785,
     2116, 2014, 2120, 2137, 2158, 2162, 2131, 2166, 2170, 2178,
     2184, 2194, 2214, 1752, 1749, 6409, 2266, 1746, 2226,   99,
     2230,  326,  370,  678,    0,    0, 1738,    0, 2202,    0,
        0, 2236,    0,    0, 2242, 2288, 2294,  389,    0, 2247,
     1690, 2318, 2322, 2328, 2381, 2434, 2486, 2251,  462, 2539,
     2592, 2443,  384, 2455,  695,  855,  551,  719,    0,    0,
     2459, 2463, 2467,    0,    0, 2471,    0,    0, 2475, 2332,

     2336, 2341, 1684, 2493, 2254, 1681, 1673, 2644, 2519, 2675,
     2525, 2706, 2562, 2480, 2555, 2737, 2567, 2768, 2617, 2799,
     2574, 2571, 6409, 2623, 2601, 2831,  922, 1414, 2628, 2634,
     2656, 2664, 2687, 2696, 2710, 2718, 2727, 2749, 2772, 2884,
     2888, 2345, 2257, 2481, 2892, 2896, 2900, 2904, 2908, 2916,
     2921, 2929, 2934, 1649, 2509, 2938, 2780, 2789, 2946, 2950,
     2954, 2958, 2962, 2968, 2974, 2984, 2992, 2996, 3000, 3006,
     3014, 3018, 3026, 3070, 3122,  296, 3153, 2804, 3184, 1597,
      188, 3215,  888, 3246, 3030, 3277, 1571, 3038, 3042, 3056,
     3060, 3050, 3065, 3082, 3074, 3092, 3100, 3106, 3111, 3116,

     3142, 3308, 3162, 3167, 3174, 3196, 3204, 3235, 3266, 3281,
     3289, 3285, 3361, 3414, 3297, 3228, 3468, 3324, 3335, 1574,
     3521, 3574, 3626,  519, 3579,  570,  509, 3586,  970, 3591,
     3596,  517, 1547,  944, 3603,  965,  430,  981, 1117,  993,
     1103,  674,  863, 1079, 3607, 1021, 1180, 1188, 3611, 1259,
     1119, 1208, 1219, 1285, 1093, 1506, 3616, 3620, 2580, 2741,
     3119, 3204, 3402, 3241, 2423, 3406, 3333, 3650, 3176, 3410,
     3414, 3424, 3428, 3436, 3641, 3645, 3650, 2698, 3670, 3664,
     3113, 3687, 3675, 3695, 6409, 3747, 3705, 3799, 3709, 3851,
     1529, 1310, 1490, 3697, 3717, 3739, 3759, 3769, 3789, 1292,

     3793, 3827, 3839, 3861, 3780, 3913, 3965, 4018, 4072, 3832,
     3873, 3885, 3904,  363, 1561, 1317, 3711, 3877, 3807, 1394,
     6409,    0,  937, 6409, 6409, 6409, 6409, 4120, 4146, 4177,
     3925, 4199, 4221, 4252, 3938, 3944, 1434, 3898, 3942, 4101,
     3935, 3956, 4105, 4109, 4115, 4127, 1338, 4132, 3976, 4140,
     4159, 4184, 4190, 4209, 3986, 4213, 4234, 4242, 3992, 4256,
     4263, 4272, 4284, 4331, 4357, 4388, 4295, 4410, 4432, 4463,
     4299, 4288, 4097, 4303, 4316, 4322, 4326, 4330, 4197, 4338,
     4343, 4494, 4369, 4398, 4402, 1463, 4422, 4444, 4467, 4547,
     4452, 4551, 4555, 1290,  844, 1489, 4559, 1258, 1615, 1086,

     1620, 1641, 4563, 4567, 1657, 1036, 4571, 1543, 1632, 4575,
     1678, 1353, 1025, 4579, 1816, 4583,  995, 4587, 3982, 3684,
     4293, 4591, 4139, 4203, 4392, 2795, 4414, 4597, 4593, 4458,
     4617, 4347, 4613, 4621, 4641, 2665, 4631, 4637, 4657, 4645,
     4651, 4671, 4677, 4729, 4683, 4781, 4833, 1534, 4688,  958,
     4693, 4698, 4702, 1480, 1690, 1402, 4709, 1596, 1372, 1581,
     4724, 4738, 4468, 4745, 4765, 6409, 4885,  878,  789, 4916,
      750,  740, 4948, 4769, 4774, 4788, 4792, 4803, 4807, 4811,
     4815, 5001,  722,  664, 5032,  635,  613, 4819, 4827, 5064,
     4838, 1718, 4842, 4857, 4869, 4873, 1624, 1840, 4880, 1454,

     1599, 1324, 5005,  929, 5040, 5045, 5080, 1667, 1845, 1700,
     5052, 5092, 5097, 5104, 5108, 5117, 5122,  591, 5126, 5132,
     4845, 5137, 4876, 3987, 4882, 4997, 4911, 4993, 5128, 5133,
     5138, 5160, 5005, 5164, 5153, 5176, 5184, 5174, 5178, 5198,
     5202, 5255, 1825, 5308, 5312, 5316, 5320, 5324, 1896, 5329,
     5382, 5335, 5374, 5398, 5358, 5370, 5190, 5198, 5450,  559,
     5481,  548, 6409, 5408, 5412, 5420, 5512,  524, 5543,  422,
     5574, 5221, 5228, 5342, 5346, 5424, 5437, 5441, 5462, 5470,
     1832,  298, 1879, 5485, 1704, 1893, 1626, 5502, 1742, 5516,
     5524, 5547, 5554, 5532, 5590, 5599, 5604, 5608, 5612, 5616,

     5221, 5335, 5604, 5611, 5631, 5635, 5478, 5227, 5627, 5649,
     5654, 5646, 5666, 5672, 5676, 5665, 5685, 5689, 6409, 1975,
     5693, 5701, 5706, 5711, 5718, 5726, 5730, 5719, 5727, 5745,
     5760, 5773, 5786, 5756, 1949, 5780, 5793, 5806, 1918,   67,
     5817, 5822, 5826, 5830, 5735, 5819, 5839, 5843, 5848, 5836,
     5731, 5842, 5862, 5872, 5880, 5884, 5889, 5893, 5884, 5888,
     5908, 1932, 5912, 5917, 5924, 1982, 2088, 5930, 5918, 5939,
     5943, 5947, 5951, 5955, 5962, 5967, 5974, 5966, 5970, 5993,
     6005, 6009, 5998, 6019, 6024, 6028, 6033, 6029, 6035, 6039,
     6055, 6061, 6065, 6055, 6078, 6085, 6089, 6093, 6097, 6409,

     6148, 6154, 6161, 6166, 6171, 6178, 6185, 6191, 6196, 6201,
     6206, 6210, 6215, 6221, 6226, 6231, 6236, 6241, 6246, 6252,
     6259, 6266, 6273, 6278, 6284, 6291, 6297, 6303, 6309, 6314,
     6319, 6324, 6329, 6334, 6339, 6345, 6352, 6359, 6364, 6370,
     6377, 6384, 6390, 6396, 6402
    } ;

static yyconst flex_int16_t yy_def[1046] =
    {   0,
     1000,    1, 1000,    3,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1, 1000,   19,
        1,    1, 1000,   23,    1,    1,    1,    1,    1,    1,
     1000, 1000, 1000, 1000,   33, 1001, 1002, 1000, 1000, 1003,
     1000, 1000, 1000, 1000, 1000, 1000, 1004, 1000, 1000, 1000,
     1000, 1000, 1000, 1000, 1001, 1001, 1001, 1001, 1001, 1000,
       33, 1000,   33,   63, 1005, 1006, 1007, 1000, 1000, 1005,
       70,   70,   70,   70,   70,   70,   70,   70,   70,   70,
       70,   70,   70,   70,   70,   70,   63,   33,   88, 1001,
     1001,   88, 1001, 1001, 1001, 1001, 1001, 1001, 1001, 1001,

     1001, 1001, 1001, 1001, 1001, 1001, 1001, 1001, 1001, 1001,
     1001, 1008, 1009, 1008,  114,  114,  114,  114,   33,  119,
     1001,  119, 1000,  123, 1010, 1011, 1000, 1010,  128,  128,
      128,  128,  128,  123,  119, 1000,  135, 1000,  135, 1001,
     1001, 1001,   33, 1000,   33, 1000, 1000, 1000, 1000, 1000,
     1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000,   33, 1000,
     1000, 1001, 1001, 1002, 1000, 1002,  166, 1000, 1000, 1000,
     1000, 1003, 1000, 1003,  174, 1000, 1000, 1000, 1000, 1000,
     1000, 1000, 1012, 1012,   49, 1004, 1004, 1000, 1000, 1000,
     1000,  185,   49, 1012, 1000, 1000, 1000, 1000, 1000, 1000,

     1000, 1000, 1000, 1000, 1000, 1000, 1001, 1001,  207, 1001,
     1001, 1001, 1000, 1000, 1000, 1000, 1000,   33,   33,   61,
     1000, 1000, 1000,   63,   63, 1000,   63, 1000,   70, 1000,
     1000, 1000, 1000, 1000,   70, 1000, 1000, 1000, 1000, 1006,
     1000, 1006,  242, 1007, 1000, 1007,  246, 1000, 1013, 1000,
     1000, 1000, 1000, 1000, 1013, 1000,  255, 1000, 1000,  259,
     1000,  248, 1000, 1000, 1000, 1000, 1000,  257, 1000,  257,
     1000, 1000,  255, 1000,   70,   70,   70,   70,   70,   70,
       70,   70,   70,   70,   70,   70,   70,   70,   70,   70,
       70,   70,   70,   70,   70,   70,   70,   70,   70,   70,

       70,   70,   70,   70,   70,   70,   70,   63,   63,   63,
       88,   88, 1000,   88, 1001,  207, 1001,   88,   88,   88,
     1001, 1001, 1001, 1001, 1001, 1001, 1001, 1001, 1001, 1001,
     1001, 1001, 1001, 1001, 1001, 1001, 1001, 1001, 1001, 1001,
     1001, 1001, 1000,  114,  114, 1000, 1009,  347,  114,  114,
      114,  114,  114,  114,  119,  119, 1000,  119, 1001,  119,
      119,  119,  123,  123, 1014, 1015, 1014,  367,  123, 1000,
      128, 1016, 1017, 1018, 1000, 1019, 1019, 1000,  375,  375,
     1017,  128,  128,  128,  128,  128,  128,  128,  123,  123,
      123,  119, 1000,  392,  392, 1000,  392,  392,  392, 1001,

     1001, 1001, 1000, 1000, 1000, 1020, 1021, 1022, 1000, 1022,
      410,  410, 1000, 1000, 1000, 1023, 1000, 1023,  418,  418,
     1000, 1000, 1000, 1024, 1000, 1000, 1000,  426, 1000, 1000,
     1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000,  207,
     1000, 1001, 1001, 1001, 1000, 1000, 1000, 1000, 1000, 1000,
     1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000,
     1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000,
     1000, 1000, 1000, 1000, 1025,  474, 1025,  477,  477,  474,
      474, 1026,  481, 1026,  484,  484,  481, 1000, 1000, 1000,
     1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000,

     1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000,
     1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000,  517,
     1000,  521, 1000,  521,  523,  521,  521,  521,  521,  521,
      523,  521,  521,  521,  521,  521,  521,  521,  521,  521,
      521,  521,  521,  521,  521,  521,  521,  521,  523,  521,
      521,  521,  521,  521,  521, 1000,  207, 1000, 1001, 1001,
     1001, 1001, 1001, 1001, 1001, 1001, 1001,  207, 1001, 1001,
     1001, 1001, 1001, 1001, 1001, 1001, 1001, 1001,  207, 1001,
     1001,  207, 1001, 1000, 1000, 1027, 1000, 1028, 1000, 1028,
      590,  590, 1000, 1001, 1029, 1030, 1030, 1031, 1029,  599,

     1032, 1032, 1033, 1033, 1000, 1034, 1034, 1000,  604, 1000,
     1035, 1000, 1035,  613,  613,  613, 1001, 1001, 1001, 1000,
     1000, 1036, 1000, 1000, 1000, 1000, 1000, 1037, 1037, 1037,
      630, 1038, 1038, 1038,  634, 1039, 1040, 1000, 1000, 1000,
     1001, 1001,  207, 1000, 1000, 1000, 1000, 1000, 1000, 1000,
     1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000,
     1000, 1000, 1000, 1041, 1041, 1041,  666, 1042, 1042, 1042,
      670, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000,
     1000, 1000, 1000, 1000, 1000,  521,  523,  521,  521,  521,
      523,  521,  523,  521,  521,  521,  523,  521,  521,  521,

      521,  521,  521,  521,  521,  521,  523,  521,  521,  521,
      521,  521,  521,  521,  521,  521, 1000, 1000, 1001, 1001,
     1001,  207, 1001, 1001, 1001, 1001, 1001, 1000, 1001, 1001,
     1001, 1001, 1001, 1001,  207, 1001, 1001, 1001, 1000, 1001,
     1001,  207,  207, 1043, 1000, 1044, 1044,  747,  747, 1000,
      207, 1045, 1045,  599,  599,  607, 1000,  613,  613,  613,
      613,  207, 1001, 1001, 1000, 1000,  630,  767,  630,  634,
      770,  634, 1000,  207,  207, 1000, 1000, 1000, 1000, 1000,
     1000,  666,  782,  666,  670,  785,  670, 1000, 1000,  682,
     1000,  521,  523,  523,  523,  523,  521,  521,  521,  521,

      521,  521,  521,  521,  523,  523,  521,  521,  521,  521,
      523,  521,  521,  521,  523,  521,  523, 1000,  207,  207,
     1001, 1000, 1001, 1001, 1001, 1001, 1001, 1001, 1001, 1001,
     1001,  207, 1001, 1000, 1001,  207,  207, 1001, 1001, 1000,
     1000, 1000,  747,  747,  747, 1000, 1000, 1000,  599,  599,
      607,  613,  613,  613, 1000, 1000, 1001, 1001,  630,  630,
      634,  634, 1000, 1000, 1000, 1000,  666,  666,  670,  670,
     1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000,
      521,  521,  521,  523,  521,  521,  521,  523,  521,  523,
      521,  521,  521,  523,  523,  523,  523, 1000, 1000, 1000,

     1001, 1001, 1001, 1001,  207,  207, 1001, 1001, 1001,  207,
     1000, 1001,  207, 1000, 1000, 1001,  207, 1000, 1000,  747,
     1000, 1000,  599, 1000, 1000, 1000, 1000, 1001, 1001,  630,
      634,  666,  670,  521,  521,  521,  521,  521,  521,  521,
      523,  523,  523,  207, 1001, 1001,  207, 1000, 1000, 1001,
     1001, 1001, 1000,  207, 1000,  207, 1000,  747, 1001, 1001,
      523,  521,  523,  523,  523,  521,  521, 1000, 1001,  207,
     1000,  207,  207,  207, 1000, 1000, 1000, 1001, 1001,  521,
      521,  521, 1001, 1000, 1000, 1000, 1000, 1001, 1001,  523,
      523,  523,  207, 1001,  207, 1000,  207, 1000, 1000,    0,

     1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000,
     1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000,
     1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000,
     1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000,
     1000, 1000, 1000, 1000, 1000
    } ;

static yyconst flex_uint16_t yy_nxt[6464] =
    {   0,
       32,   33,   34,   33,   35,   36,   37,   36,   38,   39,
       40,   41,   42,   43,   44,   45,   46,   47,   48,   49,
       49,   50,   51,   52,   53,   54,   36,   55,   36,   36,
       36,   56,   36,   36,   36,   36,   36,   36,   36,   36,
       36,   36,   36,   36,   57,   58,   36,   59,   36,   36,
       36,   60,   61,   62,   32,   63,   34,   63,   64,   65,
       66,   65,   38,   39,   67,   41,   42,   43,   44,   45,
       46,   68,   48,   69,   69,   50,   51,   52,   53,   54,
       70,   71,   72,   73,   74,   75,   65,   65,   76,   65,
       77,   65,   78,   79,   80,   81,   82,   83,   84,   85,

       65,   86,   65,   65,   65,   60,   87,   62,   88,  967,
       88,   89,   88,  386,   88,   89,   93,   94,  229,   95,
       93,   94,   96,   95,   97,  110,   96,  111,   97,   98,
      110,  229,  111,   98,  229,  288,  371,  119,  277,  119,
      120,  588,  161,  229,  161,  161,   90,  229,  344,  119,
       90,  119,  120,   91,  229,  297,  229,   91,  163,   92,
      163,  163,  229,   92,  100,  172,  101,  229,  102,  163,
      103,  163,  163,  291,  104,  229,  105,  292,  106,  352,
      121,  107,  406,  108,  109,  100,  350,  101,  122,  102,
      344,  103,  121,  161, 1000,  104,  344,  105,  244,  106,

      122,  207,  107,  407,  108,  109,   32,   33,   34,   33,
       35,  112,   37,  112,   38,   39,   40,   41,   42,   43,
       44,   45,   46,  113,   48,   49,   49,   50,   51,   52,
       53,   54,  112,  114,  112,  112,  112,  115,  112,  112,
      112,  112,  112,  112,  112,  112,  112,  112,  112,  112,
      116,  117,  112,  118,  112,  112,  112,   60,   61,   62,
       32,  123,   34,  123,  124,  125,   37,  125,   38,   39,
       40,   41,   42,   43,   44,   45,   46,  126,   48,  127,
      127,   50,   51,   52,   53,   54,  125,  128,  125,  125,
      125,  129,  125,  125,  125,  125,  125,  125,  125,  125,

      125,  125,  125,  125,  130,  131,  132,  133,  125,  125,
      125,   60,  134,   62,  135,  136,  135,  137,  135,  136,
      135,  137,   88,  406,   88,   89,   88,  278,   88,   89,
      229,  168,  351,  168,  168,  138,  229,  426,  426,  138,
      935,  229,  344,  229,  407,  169,  279,  169,  169,  280,
      304,  141,  305,  170,  229,  141,  176,  121,  176,  176,
      177,  121,  177,  177,  142,  139,  383,   91,  142,  139,
      590,   91,  178,   92,  229,  344,  371,   92,  143,  144,
      143,  145,  168,  385,  284,  146,  147,  229,  384,  148,
      149,  150,  151,  152,  371,  153,  171,  371,  371,  144,

      154,  155,  156,  163,  591,  163,  163,  176,  759,  229,
      180,  179,  180,  180,  181,  595,  181,  181,  182,  344,
      182,  182,  229,  600,  157,  208,  611,  229,  158,  159,
      160,  165,  188,  371,  188,  188,  163,  289,  163,  163,
      229,  870,  244,  290,  166,  167,  517,  517,  183,  189,
      183,  167,  167,  167,  167,  167,  167,  173,  209,  406,
      184,  180,  185,  185,  699,  181,  174,  175,  163,  182,
      163,  163,  229,  175,  175,  175,  175,  175,  175,  187,
      407,  608,  608,  190,  191,  191,  191,  191,  191,  183,
      191,  183,  191,  191,  191,  191,  191,  191,  191,  191,

      191,  192,  191,  193,  193,  191,  191,  191,  191,  191,
      183,  183,  183,  183,  194,  183,  183,  183,  183,  183,
      183,  183,  183,  183,  183,  183,  183,  183,  183,  183,
      183,  183,  183,  183,  183,  191,  191,  191,  161,  690,
      161,  161,  195,  868,  195,  195,  200,  694,  200,  200,
      204,  229,  204,  204,  163,  688,  163,  163,  521,  229,
      163,  229,  163,  163,  196,  197,  198,  862,  197,  201,
      202,  229,  198,  202,  205,  210,  211,  212,  860,  229,
      213,  528,  213,  213,  218,  615,  218,  219,  221,  161,
      221,  221,  229,  199,  229,  296,  308,  203,  308,  309,

      371,  206,  214,  215,  216,  224,  229,  224,  225,  229,
      689,  285,  229,  281,  293,  282,  229,  229,  286,  229,
      301,  898,  229,  229,  287,  283,  302,  306,  307,  303,
      294,  217,  870,  295,  298,  220,  229,  229,  299,  222,
      223,  311,  300,  311,  312,  353,  354,  310,  226,  163,
      229,  163,  163,  229,  669,  229,  227,  228,  317,  228,
      228,  344,  387,  388,  230,  231,  229,  527,  530,  232,
      233,  229,  234,  235,  236,  235,  235,  237,  371,  163,
      238,  163,  163,  868,  539,  229,  313,  318,  522,  318,
      319,  229,  314,  315,  163,  538,  163,  163,  229,  163,

      316,  163,  163,  163,  229,  163,  163,  704,  228,  239,
      241,  163,  322,  163,  163,  163,  229,  163,  163,  321,
      323,  324,  592,  242,  243,  208,  163,  344,  163,  163,
      243,  243,  243,  243,  243,  243,  245,  325,  320,  613,
      163,  665,  163,  163,  371,  246,  247,  210,  163,  337,
      163,  163,  247,  247,  247,  247,  247,  247,  248,  862,
      248,  248,  249,  616,  249,  250,  251,  229,  371,  633,
      252,  253,  326,  254,  255,  256,  257,  257,  237,  327,
      229,  258,  532,  259,  259,  259,  259,  259,  259,  259,
      259,  259,  259,  260,  259,  259,  259,  259,  259,  259,

      259,  259,  259,  259,  259,  259,  259,  259,  860,  248,
      261,  191,  262,  191,  262,  262,  249,  191,  249,  263,
      264,  191,  191,  191,  265,  266,  191,  267,  268,  269,
      270,  270,  271,  191,  191,  272,  191,  249,  249,  249,
      249,  273,  249,  249,  249,  249,  249,  249,  249,  249,
      249,  249,  249,  249,  249,  249,  249,  249,  249,  249,
      249,  249,  191,  262,  274,  228,  229,  228,  228,  518,
      798,  519,  230,  231,  520,  520,  526,  232,  233,  229,
      234,  235,  236,  235,  235,  237,  229,  163,  238,  163,
      163,  614,  163,  275,  163,  163,  163,  629,  163,  163,

      163,  329,  163,  163,  371,  229,  276,  163,  705,  163,
      163,  163,  328,  163,  163,  406,  228,  239,  163,  229,
      163,  163,  164,  163,  332,  163,  163,  330,  331,  333,
      535,  163,  229,  163,  163,  163,  407,  163,  163,  334,
      338,  637,  637,  406,  339,  336,  335,  163,  621,  163,
      163,  183,  340,  183,  343,  229,  343,  343,  889,  355,
      529,  355,  356,  184,  407,  185,  185,  229,  229,  341,
      345,  229,  345,  345,  524,  342,  163,  346,  163,  163,
      229,  360,  348,  360,  361,  370,  229,  370,  370,  623,
      696,  389,  359,  389,  390,  698,  847,  370,  209,  370,

      370,  372,  357,  372,  372,  343,  343,  229,  343,  343,
      358,  700,  229,  372,  692,  372,  372,  392,  393,  392,
      394,  702,  345,  229,  345,  345,  229,  533,  163,  346,
      163,  163,  362,  229,  543,  229,  370,  400,  393,  229,
      818,  163,  391,  163,  163,  382,  229,  163,  370,  163,
      163,  708,  402,  184,  349,  184,  184,  343,  363,  144,
      363,  364,  365,  229,  365,  146,  147,  814,  395,  148,
      149,  150,  151,  152,  366,  153,  366,  366,  808,  144,
      154,  155,  156,  365,  365,  365,  365,  365,  365,  365,
      365,  365,  365,  365,  365,  365,  365,  365,  365,  365,

      365,  365,  365,  367,  368,  365,  365,  365,  158,  369,
      160,  370,  229,  370,  370,  373,  163,  373,  163,  163,
      404,  229,  404,  404,  706,  229,  716,  374,  802,  375,
      375,  412,  545,  412,  412,  229,  413,  401,  420,  703,
      420,  420,  214,  215,  216,  229,  377,  421,  184,  411,
      184,  184,  427,  712,  427,  184,  419,  428,  428,  229,
      701,  229,  370,  191,  378,  191,  378,  378,  373,  191,
      373,  191,  191,  191,  191,  191,  191,  191,  191,  191,
      379,  191,  380,  380,  191,  191,  191,  191,  191,  373,
      373,  373,  373,  381,  373,  373,  373,  373,  373,  373,

      373,  373,  373,  373,  373,  373,  373,  373,  373,  373,
      373,  373,  373,  373,  191,  378,  191,  396,  709,  396,
      396,  396,  229,  396,  396,  397,  710,  397,  398,  161,
      229,  161,  161,  168,  229,  168,  168,  169,  713,  169,
      169,  177,  536,  177,  177,  170,  180,  229,  180,  180,
      229,  229,  181,  178,  181,  181,  182,  714,  182,  182,
      188,  229,  188,  188,  229,  229,  537,  195,  396,  195,
      195,  200,  396,  200,  200,  540,  399,  189,  229,  221,
      161,  221,  221,  161,  168,  161,  161,  711,  171,  196,
      197,  198,  179,  197,  201,  202,  168,  180,  168,  168,

      800,  229,  204,  181,  204,  204,  163,  182,  163,  163,
      229,  190,  169,  534,  169,  169,  229,  546,  199,  240,
      170,  715,  203,  229,  198,  202,  205,  229,  595,  229,
      222,  223,  797,  442,  161,  414,  755,  414,  414,  171,
      406,  171,  171,  749,  344,  229,  176,  168,  176,  176,
      761,  371,  550,  206,  408,  229,  408,  408,  229,  409,
      544,  407,  177,  171,  177,  177,  229,  163,  229,  163,
      163,  887,  410,  411,  178,  422,  777,  422,  422,  411,
      411,  411,  411,  411,  411,  179,  414,  179,  179,  813,
      171,  416,  440,  416,  416,  229,  180,  176,  180,  180,

      417,  181,  853,  181,  181,  182,  371,  182,  182,  418,
      419,  229,  163,  179,  163,  163,  419,  419,  419,  419,
      419,  419,  552,  183,  229,  183,  422,  765,  163,  443,
      163,  163,  851,  428,  428,  184,  179,  184,  184,  425,
      606,  425,  425,  190,  183,  190,  190,  180,  432,  229,
      432,  432,  181,  637,  637,  444,  182,  423,  423,  423,
      423,  423,  229,  423,  551,  423,  423,  423,  423,  423,
      423,  423,  423,  423,  184,  423,  185,  185,  423,  423,
      423,  423,  423,  183,  188,  183,  188,  188,  885,  433,
      425,  433,  433,  792,  190,  184,  229,  184,  184,  432,

      195,  189,  195,  195,  429,  229,  429,  429,  423,  423,
      423,  199,  424,  199,  199,  200,  595,  200,  200,  799,
      750,  229,  196,  197,  198,  849,  434,  430,  434,  434,
      435,  229,  435,  435,  229,  190,  555,  197,  201,  202,
      433,  203,  717,  203,  203,  204,  229,  204,  204,  547,
      436,  199,  436,  436,  206,  431,  206,  206,  441,  229,
      441,  441,  199,  344,  845,  748,  203,  198,  202,  205,
      344,  809,  439,  437,  439,  439,  213,  434,  213,  213,
      445,  435,  445,  445,  448,  229,  448,  448,  163,  695,
      163,  163,  203,  520,  520,  371,  206,  760,  214,  215,

      216,  438,  446,  447,  249,  206,  447,  449,  450,  441,
      451,  854,  451,  451,  217,  371,  217,  217,  221,  407,
      221,  221,  222,  439,  222,  222,  453,  217,  453,  453,
      371,  435,  852,  450,  452,  433,  455,  886,  455,  455,
      457,  229,  457,  457,  460,  407,  460,  460,  458,  462,
      803,  462,  462,  464,  801,  464,  464,  229,  810,  456,
      939,  432,  229,  459,  882,  217,  229,  461,  229,  222,
      223,  804,  463,  222,  229,  229,  465,  453,  228,  647,
      228,  228,  541,  229,  627,  230,  231,  807,  229,  542,
      232,  233,  625,  234,  466,  236,  466,  466,  237,  229,

      469,  238,  469,  469,  470,  891,  470,  470,  812,  229,
      471,  467,  471,  471,  229,  548,  479,  468,  479,  479,
      229,  480,  486,  850,  486,  486,  595,  229,  620,  228,
      239,  487,  937,  472,  478,  488,  893,  488,  488,  371,
      485,  490,  229,  490,  490,  163,  229,  163,  163,  491,
      493,  469,  493,  493,  495,  470,  495,  495,  489,  557,
      229,  881,  473,  475,  492,  475,  475,  512,  476,  512,
      512,  593,  497,  494,  497,  497,  488,  496,  488,  488,
      586,  477,  478,  499,  229,  499,  499,  940,  478,  478,
      478,  478,  478,  478,  482,  498,  482,  482,  344,  489,

      500,  344,  163,  483,  163,  163,  501,  514,  556,  514,
      514,  513,  484,  485,  163,  481,  163,  163,  512,  485,
      485,  485,  485,  485,  485,  248,  474,  248,  248,  570,
      515,  561,  250,  251,  229,  553,  454,  252,  253,  554,
      254,  490,  256,  490,  490,  237,  816,  229,  258,  491,
      493,  415,  493,  493,  469,  920,  469,  469,  229,  516,
      495,  344,  495,  495,  492,  497,  405,  497,  497,  512,
      403,  512,  512,  494,  229,  934,  248,  261,  248, 1000,
      248,  248,  229,  496,  883,  250,  251,  229,  498,  892,
      252,  253,  140,  254,  255,  256,  255,  255,  237,  140,

      499,  258,  499,  499,  514,  469,  514,  514,  308,  936,
      308,  309,  523,   99,  523,  523,  558,  500,  558,  558,
      512,  229,  163,  501,  163,  163,  923,  515,   99,  248,
      261,  248,  595,  248,  248,  229,  938, 1000,  250,  251,
      229,  559, 1000,  252,  253, 1000,  254,  255,  256,  255,
      255,  237, 1000,  229,  258,  163,  516,  163,  163,  310,
      229,  966,  318,  523,  318,  319,  163,  558,  163,  163,
      163, 1000,  163,  163,  229,  163,  980,  163,  163,  962,
      560,  568,  248,  261,  423,  502,  423,  502,  502,  562,
      423,  229,  503,  504,  423,  423,  423,  505,  506,  423,

      507,  563,  508,  257,  257,  509,  423,  423,  510,  423,
     1000,  344,  981,  320,  273, 1000,  163,  958,  163,  163,
      163, 1000,  163,  163,  229, 1000, 1000,  163, 1000,  163,
      163,  163, 1000,  163,  163,  423,  502,  511,  248,  567,
      248,  248,  249, 1000,  249,  250,  251,  564,  566,  565,
      252,  253,  572,  254,  255,  256,  255,  255,  237, 1000,
     1000,  258, 1000,  259,  259,  259,  259,  259,  259,  259,
      259,  259,  259,  259,  259,  259,  259,  259,  259,  259,
      259,  259,  259,  259,  259,  259,  259,  259, 1000,  248,
      261,  191,  262,  191,  262,  262, 1000,  191, 1000,  263,

      264,  191,  191,  191,  265,  266,  191,  267,  268,  269,
      270,  270,  271,  191,  191,  272,  191,  525,  982,  525,
      525,  531, 1000,  531,  531,  549, 1000,  549,  549,  163,
      229,  163,  163,  163, 1000,  163,  163,  163, 1000,  163,
      163, 1000,  191,  262,  274,  229, 1000, 1000,  163,  229,
      163,  163, 1000,  229,  163,  569,  163,  163,  229, 1000,
     1000, 1000,  229,  571, 1000, 1000,  229,  573,  525, 1000,
     1000,  577,  531, 1000,  574,  163,  549,  163,  163,  163,
     1000,  163,  163,  163, 1000,  163,  163,  163, 1000,  163,
      163, 1000, 1000, 1000,  575,  163, 1000,  163,  163, 1000,

     1000,  163,  578,  163,  163, 1000, 1000,  576,  579, 1000,
      581,  163,  580,  163,  163,  343, 1000,  343,  343,  163,
     1000,  163,  163, 1000, 1000, 1000,  582,  587, 1000,  587,
      587,  589,  594,  589,  589, 1000, 1000,  360,  346,  360,
      361, 1000, 1000,  370,  583,  370,  370, 1000,  370, 1000,
      370,  370,  370, 1000,  370,  370, 1000, 1000, 1000,  596,
      164,  596,  596, 1000, 1000,  621,  343,  584, 1000,  584,
      584,  183, 1000,  183,  163,  344,  163,  163,  587,  344,
     1000,  622,  589,  184, 1000,  184,  184, 1000,  362,  370,
      585,  370,  370,  642,  370,  370, 1000,  370,  370,  370,

     1000, 1000,  622,  370, 1000,  598,  623,  598,  598, 1000,
     1000,  596, 1000,  596,  596, 1000, 1000, 1000,  584,  370,
      599,  370,  370,  370, 1000,  370,  370, 1000, 1000,  370,
     1000,  370,  370, 1000, 1000,  602, 1000,  602,  602,  604,
      370,  604,  604, 1000, 1000,  374,  370,  374,  374,  163,
     1000,  163,  163,  163, 1000,  163,  163, 1000,  163, 1000,
      163,  163,  163, 1000,  163,  163, 1000, 1000,  618,  617,
      370, 1000, 1000, 1000,  370,  619, 1000, 1000, 1000,  641,
      370,  423,  605,  423,  605,  605,  373,  423,  373,  423,
      423,  423,  423,  423,  423,  423,  423,  423,  374,  423,

      375,  375,  423,  423,  423,  423,  423,  373,  373,  373,
      373,  381,  373,  373,  373,  373,  373,  373,  373,  373,
      373,  373,  373,  373,  373,  373,  373,  373,  373,  373,
      373,  373,  423,  605,  423,  370, 1000,  370,  370,  603,
      163,  603,  163,  163,  610, 1000,  610,  610, 1000,  725,
     1000,  604, 1000,  604,  604, 1000,  612, 1000,  612,  612,
      389, 1000,  389,  390,  392,  393,  392,  394,  396, 1000,
      396,  396,  396, 1000,  396,  396,  397, 1000,  397,  398,
     1000,  414, 1000,  414,  414,  393,  370,  370, 1000,  370,
      370,  603,  371,  603,  404,  610,  404,  404,  163, 1000,

      163,  163, 1000,  604,  371,  604,  604,  612, 1000, 1000,
      455,  391,  455,  455,  643,  395,  214,  215,  216,  396,
      607, 1000, 1000,  396, 1000,  164,  412,  399,  412,  412,
      621,  413,  414,  456, 1000, 1000, 1000, 1000,  370,  191,
      378,  191,  378,  378,  631,  191,  406,  191,  191,  191,
      191,  191,  191,  191,  191,  191,  379,  191,  380,  380,
      191,  191,  191,  191,  191,  172,  621,  407,  164, 1000,
     1000,  623,  422,  621,  422,  422, 1000,  172,  621, 1000,
     1000, 1000,  622, 1000,  172,  621, 1000, 1000, 1000,  622,
      191,  378,  191,  370,  406,  370,  370,  163, 1000,  163,

      163,  622,  425,  622,  425,  425,  427,  623,  427,  604,
      407,  609,  609, 1000,  623,  407, 1000, 1000,  420,  623,
      420,  420,  407,  422, 1000,  719,  623,  421,  183,  429,
      183,  429,  429, 1000, 1000,  638,  635,  638,  638, 1000,
      184, 1000,  184,  184,  370,  408, 1000,  408,  408, 1000,
      405, 1000,  430,  425, 1000, 1000, 1000,  431, 1000,  431,
      431,  636, 1000,  628,  629,  432, 1000,  432,  432, 1000,
      629,  629,  629,  629,  629,  629,  408, 1000,  408,  408,
      431,  409,  163, 1000,  163,  163,  638, 1000,  433, 1000,
      433,  433, 1000,  835,  630,  631, 1000,  434, 1000,  434,

      434,  631,  631,  631,  631,  631,  631,  412,  431,  412,
      412,  435,  405,  435,  435,  163,  432,  163,  163,  436,
     1000,  436,  436, 1000, 1000,  629,  629, 1000,  639, 1000,
      639,  639,  629,  629,  629,  629,  629,  629,  416,  433,
      416,  416,  437,  738, 1000, 1000, 1000,  415,  434, 1000,
      438, 1000,  438,  438, 1000, 1000,  632,  633,  163, 1000,
      163,  163,  435,  633,  633,  633,  633,  633,  633,  416,
      438,  416,  416,  439, 1000,  439,  439, 1000,  417,  639,
      720,  457, 1000,  457,  457, 1000, 1000,  634,  635,  458,
      649, 1000,  649,  649,  635,  635,  635,  635,  635,  635,

      420,  438,  420,  420,  459,  479, 1000,  479,  479,  415,
      480, 1000,  163,  650,  163,  163, 1000, 1000,  633,  633,
     1000,  826, 1000,  667,  439,  633,  633,  633,  633,  633,
      633,  423,  423,  423,  423,  423,  183,  423,  183,  423,
      423,  423,  423,  423,  423,  423,  423,  423,  184,  423,
      426,  426,  423,  423,  423,  423,  423,  183,  183,  183,
      183,  194,  183,  183,  183,  183,  183,  183,  183,  183,
      183,  183,  183,  183,  183,  183,  183,  183,  183,  183,
      183,  183,  423,  423,  423,  640, 1000,  640,  640,  441,
     1000,  441,  441,  445, 1000,  445,  445,  644, 1000,  644,

      644,  206, 1000,  206,  206,  448, 1000,  448,  448,  645,
     1000,  645,  645, 1000, 1000,  446,  447,  199, 1000,  199,
      199, 1000,  451, 1000,  451,  451, 1000,  447,  449,  450,
      646, 1000,  646,  646, 1000,  453,  640,  453,  453,  648,
      441,  648,  648, 1000,  435,  450,  452,  651,  644,  651,
      651,  460,  206,  460,  460,  652,  433,  652,  652,  462,
      645,  462,  462,  653, 1000,  653,  653, 1000,  199,  464,
     1000,  464,  464,  432,  461,  654, 1000,  654,  654, 1000,
     1000,  646,  463, 1000, 1000,  466,  453,  466,  466, 1000,
      648, 1000,  465,  655, 1000,  655,  655,  657,  651,  657,

      657,  469,  467,  469,  469, 1000,  652,  470,  468,  470,
      470, 1000, 1000, 1000,  653,  471,  656,  471,  471,  658,
     1000,  658,  658, 1000, 1000, 1000,  654,  659, 1000,  659,
      659,  486, 1000,  486,  486, 1000, 1000, 1000,  472,  488,
      487,  488,  488,  672, 1000,  672,  672, 1000,  657,  671,
      660,  675,  469,  675,  675, 1000, 1000,  490,  470,  490,
      490,  673,  489,  673,  673,  491,  493,  473,  493,  493,
      658,  661, 1000,  661,  661,  495,  240,  495,  495, 1000,
      492,  621, 1000,  676,  674,  676,  676, 1000, 1000,  494,
     1000,  662, 1000,  677,  672,  677,  677,  622,  496, 1000,

     1000,  497,  675,  497,  497, 1000, 1000,  678, 1000,  678,
      678, 1000,  499, 1000,  499,  499, 1000,  679,  622,  679,
      679, 1000,  663,  475,  498,  475,  475, 1000,  474,  500,
      163, 1000,  163,  163,  676,  501,  163, 1000,  163,  163,
      680,  664,  665,  681,  677,  681,  681,  741,  665,  665,
      665,  665,  665,  665,  475,  721,  475,  475,  678,  476,
     1000, 1000, 1000,  488, 1000,  488,  488, 1000,  490, 1000,
      490,  490,  666,  667, 1000,  493,  491,  493,  493,  667,
      667,  667,  667,  667,  667,  479,  489,  479,  479, 1000,
      474,  492, 1000,  163,  681,  163,  163,  495,  494,  495,

      495, 1000, 1000,  665,  665,  497,  729,  497,  497, 1000,
      665,  665,  665,  665,  665,  665,  482, 1000,  482,  482,
      496,  163, 1000,  163,  163,  481, 1000, 1000,  498,  684,
     1000,  684,  684, 1000,  668,  669,  499, 1000,  499,  499,
     1000,  669,  669,  669,  669,  669,  669,  482,  722,  482,
      482, 1000,  685,  500, 1000, 1000,  483, 1000,  163,  501,
      163,  163, 1000, 1000, 1000,  670,  671,  469, 1000,  469,
      469, 1000,  671,  671,  671,  671,  671,  671,  486, 1000,
      486,  486,  512,  724,  512,  512,  512,  481,  512,  512,
      514, 1000,  514,  514, 1000, 1000,  669,  669,  683, 1000,

      683,  683, 1000,  669,  669,  669,  669,  669,  669,  248,
     1000,  248,  248,  515, 1000, 1000,  250,  251,  469, 1000,
     1000,  252,  253, 1000,  254,  495,  256,  495,  495,  237,
     1000, 1000,  258,  512, 1000, 1000,  497,  512,  497,  497,
     1000, 1000,  516,  637,  637, 1000, 1000, 1000,  496,  683,
      163, 1000,  163,  163,  637,  637, 1000, 1000, 1000,  498,
      248,  261,  248, 1000,  248,  248,  249, 1000,  249,  250,
      251, 1000,  727, 1000,  252,  253, 1000,  254,  255,  256,
      255,  255,  237, 1000, 1000,  258, 1000,  259,  259,  259,
      259,  259,  259,  259,  259,  259,  259,  259,  259,  682,

      259,  259,  259,  259,  259,  259,  259,  259,  259,  259,
      259,  259, 1000,  248,  261,  514, 1000,  514,  514,  163,
     1000,  163,  163,  163, 1000,  163,  163,  163, 1000,  163,
      163,  163, 1000,  163,  163, 1000, 1000, 1000,  515, 1000,
      730,  163, 1000,  163,  163,  163,  723,  163,  163, 1000,
      726, 1000,  731,  163,  732,  163,  163, 1000,  733, 1000,
     1000, 1000, 1000, 1000, 1000, 1000,  734,  516,  423,  502,
      423,  502,  502,  249,  423,  249,  503,  504,  423,  423,
      423,  505,  506,  423,  507,  255,  508,  517,  517,  509,
      423,  423,  510,  423,  249,  249,  249,  249,  273,  249,

      249,  249,  249,  249,  249,  249,  249,  249,  249,  249,
      249,  249,  249,  249,  249,  249,  249,  249,  249,  423,
      502,  511,  228, 1000,  228,  228,  229, 1000,  229,  230,
      231, 1000, 1000, 1000,  232,  233, 1000,  234,  235,  236,
      235,  235,  237, 1000, 1000,  238, 1000,  229,  229,  229,
      229,  229,  229,  229,  229,  229,  229,  229,  229,  229,
      229,  229,  229,  686,  229,  229,  229,  229,  229,  229,
      229,  229, 1000,  228,  239,  687, 1000,  687,  687, 1000,
      525, 1000,  525,  525, 1000, 1000, 1000,  691, 1000,  691,
      691, 1000,  693, 1000,  693,  693, 1000,  531, 1000,  531,

      531, 1000, 1000, 1000,  697, 1000,  697,  697,  707, 1000,
      707,  707,  549, 1000,  549,  549,  229,  718, 1000,  718,
      718,  558, 1000,  558,  558, 1000,  687,  523,  229,  523,
      523,  525, 1000,  229,  230,  231, 1000, 1000,  691,  232,
      233, 1000,  234,  693,  236,  229, 1000,  237,  531,  229,
      238,  728, 1000,  728,  728,  697, 1000, 1000,  163,  707,
      163,  163,  163,  549,  163,  163, 1000,  163,  718,  163,
      163,  739,  558,  739,  739, 1000, 1000,  735,  523,  239,
      737,  163, 1000,  163,  163, 1000, 1000,  736,  640, 1000,
      640,  640,  163, 1000,  163,  163,  584, 1000,  584,  584,

     1000,  163,  728,  163,  163, 1000,  587,  740,  587,  587,
      589, 1000,  589,  589,  163, 1000,  163,  163,  370,  585,
      370,  370,  739, 1000,  742,  743,  820, 1000,  163,  346,
      163,  163, 1000,  346,  596,  751,  596,  596, 1000,  640,
      370,  762,  370,  370, 1000, 1000, 1000,  584,  584, 1000,
      584,  584,  183, 1000,  183, 1000,  753,  587,  753,  753,
      370,  589,  370,  370,  184, 1000,  184,  184, 1000,  370,
      370,  585,  370,  370, 1000, 1000,  753, 1000,  753,  753,
     1000,  370, 1000,  370,  370,  744,  598, 1000,  598,  598,
      370,  370,  370,  370,  370, 1000,  370,  370, 1000,  584,

      745, 1000,  745,  745, 1000, 1000,  596, 1000,  596,  596,
      602,  370,  602,  602, 1000, 1000,  345, 1000,  345,  345,
     1000,  370, 1000,  346,  163,  754,  163,  163,  370,  746,
      370,  370,  370,  610, 1000,  610,  610,  764, 1000, 1000,
      370,  370,  370,  370,  602,  370,  602,  602, 1000, 1000,
     1000,  745,  343, 1000,  343,  343,  604, 1000,  604,  604,
     1000, 1000,  370, 1000,  370,  370, 1000, 1000,  345, 1000,
      345,  345, 1000, 1000,  757,  346,  757,  757,  604,  370,
      604,  604, 1000, 1000,  610,  747,  612, 1000,  612,  612,
      372,  370,  372,  372,  163, 1000,  163,  163, 1000,  638,

     1000,  638,  638,  343, 1000,  370, 1000,  370,  370, 1000,
     1000,  763, 1000,  370,  370, 1000,  370,  370,  603, 1000,
      603,  372, 1000,  372,  372,  757,  412, 1000,  412,  412,
      604,  413,  604,  604, 1000, 1000, 1000,  612,  758,  420,
     1000,  420,  420,  639,  631,  639,  639, 1000,  421,  183,
      638,  183,  163, 1000,  163,  163,  370,  635, 1000, 1000,
     1000,  184, 1000,  184,  184,  370,  370, 1000,  370,  370,
      603,  774,  603,  163,  773,  163,  163,  649, 1000,  649,
      649, 1000,  604, 1000,  604,  604,  775,  655, 1000,  655,
      655, 1000, 1000,  659,  639,  659,  659, 1000, 1000,  163,

      650,  163,  163,  756,  163, 1000,  163,  163, 1000, 1000,
      656, 1000,  819,  903, 1000, 1000,  660,  370,  423,  605,
      423,  605,  605,  373,  423,  373,  423,  423,  423,  423,
      423,  423,  423,  423,  423,  374,  423,  608,  608,  423,
      423,  423,  423,  423,  373,  373,  373,  373,  381,  373,
      373,  373,  373,  373,  373,  373,  373,  373,  373,  373,
      373,  373,  373,  373,  373,  373,  373,  373,  373,  423,
      605,  423,  423,  605,  423,  605,  605, 1000,  423, 1000,
      423,  423,  423,  423,  423,  423,  423,  423,  423, 1000,
      423,  609,  609,  423,  423,  423,  423,  423,  673, 1000,

      673,  673,  640, 1000,  640,  640,  776, 1000,  776,  776,
      644, 1000,  644,  644, 1000, 1000,  645, 1000,  645,  645,
     1000,  674, 1000,  423,  605,  423,  405, 1000,  646, 1000,
      646,  646, 1000,  648, 1000,  648,  648, 1000, 1000,  767,
      768,  778, 1000,  778,  778, 1000,  768,  768,  768,  768,
      768,  768,  405,  640, 1000, 1000,  163,  776,  163,  163,
      651,  644,  651,  651, 1000,  768,  768,  645,  823, 1000,
     1000, 1000,  768,  768,  768,  768,  768,  768,  408,  646,
      408,  408, 1000,  409,  648,  652, 1000,  652,  652, 1000,
     1000,  653,  778,  653,  653, 1000,  769,  631,  679, 1000,

      679,  679, 1000,  631,  631,  631,  631,  631,  631,  415,
      654,  651,  654,  654,  779, 1000,  779,  779,  770,  771,
      163,  680,  163,  163, 1000,  771,  771,  771,  771,  771,
      771,  415, 1000,  824, 1000,  657,  652,  657,  657, 1000,
      771,  771,  653,  658, 1000,  658,  658,  771,  771,  771,
      771,  771,  771,  416, 1000,  416,  416,  780, 1000,  780,
      780,  654,  417, 1000,  661,  779,  661,  661, 1000, 1000,
     1000,  772,  635,  781, 1000,  781,  781, 1000,  635,  635,
      635,  635,  635,  635,  662,  661,  657,  661,  661,  672,
     1000,  672,  672, 1000,  658,  621,  479, 1000,  479,  479,

      486,  480,  486,  486,  788,  662,  788,  788,  780,  487,
      163, 1000,  163,  163,  667,  661, 1000,  675,  671,  675,
      675, 1000, 1000,  676,  781,  676,  676,  677, 1000,  677,
      677,  678, 1000,  678,  678, 1000,  663,  474,  821,  789,
      672,  789,  789, 1000,  681, 1000,  681,  681, 1000, 1000,
      782,  783, 1000, 1000, 1000,  788, 1000,  783,  783,  783,
      783,  783,  783,  474,  163, 1000,  163,  163,  675, 1000,
      683, 1000,  683,  683,  676, 1000,  783,  783,  677, 1000,
     1000,  831,  678,  783,  783,  783,  783,  783,  783,  475,
      789,  475,  475, 1000,  476,  681, 1000, 1000, 1000,  684,

     1000,  684,  684,  791, 1000,  791,  791,  784,  667,  163,
     1000,  163,  163, 1000,  667,  667,  667,  667,  667,  667,
      481,  683,  685,  687, 1000,  687,  687, 1000,  825,  785,
      786,  163, 1000,  163,  163, 1000,  786,  786,  786,  786,
      786,  786,  481, 1000, 1000,  793, 1000,  793,  793, 1000,
     1000,  786,  786,  691,  791,  691,  691,  827,  786,  786,
      786,  786,  786,  786,  482, 1000,  482,  482,  794, 1000,
      794,  794, 1000,  483,  687,  163, 1000,  163,  163, 1000,
     1000, 1000,  787,  671, 1000,  163,  229,  163,  163,  671,
      671,  671,  671,  671,  671,  248,  793,  248,  248,  249,

      829,  249,  250,  251,  691, 1000,  857,  252,  253,  229,
      254,  255,  256,  255,  255,  237, 1000, 1000,  258,  794,
      259,  259,  259,  259,  790,  259,  259,  259,  259,  259,
      259,  259,  259,  259,  259,  259,  259,  259,  259,  259,
      259,  259,  259,  259,  259, 1000,  248,  261,  795, 1000,
      795,  795,  796, 1000,  796,  796,  693, 1000,  693,  693,
      697, 1000,  697,  697,  805, 1000,  805,  805,  806, 1000,
      806,  806,  707, 1000,  707,  707,  811, 1000,  811,  811,
      815, 1000,  815,  815,  817, 1000,  817,  817,  718,  229,
      718,  718,  822,  229,  822,  822, 1000, 1000,  728,  795,

      728,  728, 1000,  796, 1000,  229, 1000,  693, 1000,  229,
      163,  697,  163,  163, 1000,  805, 1000,  229, 1000,  806,
     1000,  229, 1000,  707, 1000,  229, 1000,  811, 1000,  828,
      163,  815,  163,  163,  163,  817,  163,  163,  163,  718,
      163,  163,  834,  822,  834,  834, 1000,  830,  163,  728,
      163,  163, 1000, 1000,  163,  832,  163,  163,  739, 1000,
      739,  739,  163,  833,  163,  163, 1000,  837,  163, 1000,
      163,  163,  840,  836,  840,  840, 1000, 1000,  841,  838,
      841,  841, 1000, 1000,  745, 1000,  745,  745, 1000,  846,
     1000,  846,  846,  834,  848,  839,  848,  848, 1000,  370,

     1000,  370,  370,  370, 1000,  370,  370,  346, 1000,  739,
      757, 1000,  757,  757, 1000,  753, 1000,  753,  753,  753,
     1000,  753,  753,  840,  344,  855, 1000,  855,  855,  841,
      584, 1000,  584,  584,  183,  745,  183, 1000, 1000,  856,
      846,  856,  856, 1000, 1000,  848,  184, 1000,  184,  184,
      370, 1000, 1000,  585,  370, 1000, 1000, 1000,  371,  842,
     1000,  757,  163, 1000,  163,  163,  776, 1000,  776,  776,
      864, 1000,  864,  864, 1000,  865,  855,  865,  865, 1000,
     1000,  584,  343,  858,  343,  343, 1000, 1000, 1000,  776,
      856,  776,  776,  866, 1000,  866,  866, 1000,  345, 1000,

      345,  345, 1000, 1000,  778,  346,  778,  778,  779, 1000,
      779,  779,  780, 1000,  780,  780,  781,  776,  781,  781,
      788,  864,  788,  788, 1000, 1000,  865,  843,  789, 1000,
      789,  789, 1000,  343,  343, 1000,  343,  343, 1000,  791,
      776,  791,  791,  793,  866,  793,  793, 1000, 1000, 1000,
      345, 1000,  345,  345, 1000,  778, 1000,  346,  794,  779,
      794,  794,  163,  780,  163,  163, 1000,  781, 1000,  844,
      795,  788,  795,  795,  796, 1000,  796,  796, 1000,  789,
     1000,  884, 1000,  884,  884,  343,  412,  901,  412,  412,
      791,  413, 1000,  163,  793,  163,  163, 1000, 1000,  163,

     1000,  163,  163, 1000,  859,  629, 1000, 1000, 1000,  794,
      902,  629,  629,  629,  629,  629,  629,  420, 1000,  420,
      420,  795,  229, 1000, 1000,  796,  421,  904,  163, 1000,
      163,  163,  884, 1000, 1000,  861,  633, 1000, 1000, 1000,
     1000,  906,  633,  633,  633,  633,  633,  633,  863,  863,
      863,  863,  863,  183,  863,  183,  863,  863,  863,  863,
      863,  863,  863,  863,  863,  184,  863,  184,  184,  863,
      863,  863,  863,  863,  186,  186,  186,  186,  186,  186,
      186,  186,  186,  186,  186,  186,  186,  186,  186,  186,
      186,  186,  186,  186,  186,  186,  186,  186,  186,  863,

      863,  863,  479, 1000,  479,  479,  888,  480,  888,  888,
      163, 1000,  163,  163,  163, 1000,  163,  163, 1000, 1000,
      867,  665,  163,  907,  163,  163, 1000,  665,  665,  665,
      665,  665,  665,  486, 1000,  486,  486, 1000, 1000,  912,
     1000,  805,  487,  805,  805,  905,  806,  229,  806,  806,
     1000,  869,  669,  811, 1000,  811,  811,  888,  669,  669,
      669,  669,  669,  669,  863,  871,  863,  871,  871, 1000,
      863, 1000,  872,  873,  863,  863,  863,  874,  875,  863,
      876,  890,  877,  890,  890,  878,  863,  863,  879,  863,
     1000, 1000,  805,  894,  259,  894,  894,  806,  895, 1000,

      895,  895, 1000, 1000,  811,  896, 1000,  896,  896,  815,
     1000,  815,  815, 1000, 1000,  863,  871,  880,  897, 1000,
      897,  897,  229,  817, 1000,  817,  817,  899, 1000,  899,
      899, 1000,  890,  900,  229,  900,  900, 1000,  822,  229,
      822,  822, 1000, 1000,  894,  163,  229,  163,  163,  895,
      163, 1000,  163,  163, 1000,  163,  896,  163,  163,  229,
      815,  911, 1000,  911,  911,  834,  908,  834,  834,  897,
      163, 1000,  163,  163,  817,  909,  910,  914,  899,  914,
      914, 1000, 1000,  913,  900,  915, 1000,  915,  915,  822,
     1000,  163, 1000,  163,  163,  163, 1000,  163,  163,  840,

     1000,  840,  840,  841, 1000,  841,  841,  163, 1000,  163,
      163, 1000,  911,  916, 1000,  163,  834,  163,  163, 1000,
      928,  917,  488, 1000,  488,  488, 1000, 1000,  914,  490,
     1000,  490,  490, 1000, 1000, 1000,  915,  491,  163, 1000,
      163,  163,  929, 1000,  163,  489,  163,  163, 1000, 1000,
      840,  944,  492,  951,  841,  863,  918,  863,  918,  918,
      183,  863,  183,  863,  863,  863,  863,  863,  863,  863,
      863,  863,  184,  863,  184,  184,  863,  863,  863,  919,
      863,  347,  347,  347,  347,  347,  347,  347,  347,  347,
      347,  347,  347,  347,  347,  347,  347,  347,  347,  347,

      347,  347,  347,  347,  347,  347,  863,  918,  863,  921,
     1000,  921,  921,  922, 1000,  922,  922,  846, 1000,  846,
      846,  848, 1000,  848,  848,  848, 1000,  848,  848, 1000,
      855, 1000,  855,  855, 1000, 1000,  925, 1000,  925,  925,
      346, 1000, 1000,  493,  344,  493,  493,  495,  344,  495,
      495, 1000,  163, 1000,  163,  163, 1000, 1000, 1000,  855,
      921,  855,  855, 1000,  922,  595,  494,  945,  846,  371,
      496,  856,  848,  856,  856,  926,  848,  926,  926, 1000,
     1000,  855,  863,  924,  863,  924,  924,  925,  863, 1000,
      863,  863,  863,  863,  863,  863,  863,  863,  863,  927,

      863,  927,  927,  863,  863,  863,  863,  863,  371,  864,
      855,  864,  864,  865, 1000,  865,  865, 1000, 1000, 1000,
      606,  866,  856,  866,  866,  497,  926,  497,  497, 1000,
     1000, 1000,  371,  863,  924,  863, 1000, 1000,  499, 1000,
      499,  499,  469, 1000,  469,  469, 1000, 1000,  498, 1000,
      927,  164, 1000,  164,  164,  500,  405, 1000, 1000, 1000,
      864,  501, 1000,  512,  865,  512,  512, 1000, 1000,  930,
      768,  514,  866,  514,  514, 1000,  768,  768,  768,  768,
      768,  768,  172, 1000,  172,  172,  884, 1000,  884,  884,
     1000,  415, 1000,  469,  515,  163, 1000,  163,  163, 1000,

      931,  771, 1000,  888, 1000,  888,  888,  771,  771,  771,
      771,  771,  771,  240,  512,  240,  240,  890,  474,  890,
      890,  950, 1000,  516, 1000,  941, 1000,  941,  941, 1000,
     1000,  932,  783,  894, 1000,  894,  894,  884,  783,  783,
      783,  783,  783,  783,  244, 1000,  244,  244,  942, 1000,
      942,  942, 1000,  481,  888,  943, 1000,  943,  943, 1000,
     1000, 1000,  933,  786, 1000, 1000,  229, 1000,  890,  786,
      786,  786,  786,  786,  786,  248,  941,  248,  248, 1000,
     1000, 1000,  250,  251,  894, 1000, 1000,  252,  253,  229,
      254,  895,  256,  895,  895,  237,  229, 1000,  258,  942,

      896, 1000,  896,  896, 1000,  897,  943,  897,  897,  899,
     1000,  899,  899,  899, 1000,  899,  899,  900, 1000,  900,
      900,  163, 1000,  163,  163, 1000,  248,  261,  163, 1000,
      163,  163,  948,  946,  948,  948,  949, 1000,  949,  949,
     1000,  947,  895, 1000,  163, 1000,  163,  163, 1000, 1000,
      953,  896,  953,  953, 1000,  911,  897,  911,  911, 1000,
      899,  952, 1000,  163,  899,  163,  163,  955,  900,  955,
      955, 1000, 1000,  914,  954,  914,  914,  915, 1000,  915,
      915, 1000,  163,  948,  163,  163,  957,  949,  957,  957,
      584, 1000,  584,  584,  921, 1000,  921,  921, 1000, 1000,

     1000,  953,  922,  956,  922,  922,  911,  926, 1000,  926,
      926, 1000,  370,  585,  370,  370, 1000,  346,  955,  925,
     1000,  925,  925, 1000,  914,  346, 1000,  926,  915,  926,
      926,  927, 1000,  927,  927, 1000,  163,  957,  163,  163,
     1000,  584,  595, 1000,  163,  921,  163,  163,  163,  959,
      163,  163,  163,  922,  163,  163, 1000,  961,  926,  961,
      961,  960, 1000,  370,  628,  629, 1000,  973, 1000,  969,
      925,  629,  629,  629,  629,  629,  629, 1000,  926,  632,
      633,  963,  927,  963,  963, 1000,  633,  633,  633,  633,
      633,  633,  664,  665,  964, 1000,  964,  964,  229,  665,

      665,  665,  665,  665,  665,  668,  669,  965,  961,  965,
      965, 1000,  669,  669,  669,  669,  669,  669,  941, 1000,
      941,  941,  229,  942, 1000,  942,  942,  943, 1000,  943,
      943,  968,  963,  968,  968,  229,  163, 1000,  163,  163,
      971, 1000,  971,  971,  948,  964,  948,  948,  229,  949,
     1000,  949,  949,  163, 1000,  163,  163, 1000,  965,  163,
     1000,  163,  163,  953, 1000,  953,  953, 1000,  970,  941,
      974, 1000, 1000,  975,  942,  975,  975, 1000,  943,  972,
     1000,  955,  968,  955,  955,  976, 1000,  976,  976, 1000,
      957,  971,  957,  957,  977,  948,  977,  977, 1000, 1000,

      949,  163, 1000,  163,  163,  163, 1000,  163,  163,  961,
     1000,  961,  961,  963,  953,  963,  963, 1000,  964,  979,
      964,  964, 1000, 1000,  975,  965,  978,  965,  965,  344,
     1000,  968,  955,  968,  968,  163,  976,  163,  163, 1000,
      984,  957,  984,  984,  971,  977,  971,  971,  985, 1000,
      985,  985,  986, 1000,  986,  986,  987, 1000,  987,  987,
      961, 1000,  983,  975,  963,  975,  975, 1000,  976,  964,
      976,  976, 1000, 1000, 1000,  977,  965,  977,  977, 1000,
     1000, 1000,  968,  163, 1000,  163,  163,  163, 1000,  163,
      163,  984, 1000, 1000,  990,  971,  990,  990,  346,  985,

      988, 1000, 1000,  986,  989, 1000,  991,  987,  991,  991,
      992, 1000,  992,  992,  975,  163, 1000,  163,  163,  976,
      984, 1000,  984,  984, 1000,  985,  977,  985,  985,  986,
     1000,  986,  986, 1000,  987,  229,  987,  987, 1000, 1000,
      990,  993,  990,  990, 1000,  990,  163,  229,  163,  163,
     1000,  229,  163, 1000,  163,  163,  991,  991,  991,  991,
     1000,  992,  992,  995,  992,  992,  996,  994,  996,  996,
     1000,  984,  163, 1000,  163,  163,  985, 1000, 1000,  998,
      986,  998,  998, 1000, 1000,  987,  996,  997,  996,  996,
      999,  990,  999,  999,  998, 1000,  998,  998,  999, 1000,

      999,  999, 1000, 1000, 1000, 1000, 1000,  991, 1000, 1000,
     1000, 1000, 1000,  992, 1000, 1000, 1000,  996, 1000, 1000,
     1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000,
      998, 1000, 1000, 1000, 1000, 1000, 1000,  996, 1000, 1000,
     1000,  999, 1000, 1000, 1000,  998, 1000, 1000, 1000,  999,
      162, 1000, 1000,  162,  164,  164,  164,  164,  164,  164,
      164,  172,  172,  172,  172,  172,  172,  172,  186, 1000,
     1000,  186,  229,  229,  229, 1000,  229,  229,  240,  240,
      240,  240,  240,  240,  240,  244,  244,  244,  244,  244,
      244,  244,  344,  344, 1000, 1000,  344,  344,  347, 1000,

     1000,  347,  371,  371, 1000, 1000,  371,  376,  376, 1000,
     1000,  376,  183, 1000, 1000,  183,  249,  249,  249, 1000,
      249,  249,  595,  595, 1000, 1000,  595,  597,  597, 1000,
     1000,  597,  601,  601, 1000, 1000,  601,  603,  603, 1000,
     1000,  603,  373,  373, 1000, 1000,  373,  606,  606, 1000,
     1000,  606,  624,  624, 1000,  624,  624, 1000,  624,  626,
      626, 1000,  626,  626, 1000,  626,  164,  164,  164,  164,
      164,  164,  164,  172,  172,  172,  172,  172,  172,  172,
      186, 1000, 1000,  186,  240,  240,  240,  240,  240,  240,
      240,  244,  244,  244,  244,  244,  244,  244,  347,  347,

     1000, 1000,  347,  347,  344,  344, 1000, 1000,  344,  344,
      595,  595, 1000, 1000,  595,  752,  752, 1000, 1000,  752,
      597,  597, 1000, 1000,  597,  601,  601, 1000, 1000,  601,
      603,  603, 1000, 1000,  603,  606,  606, 1000, 1000,  606,
      371,  371, 1000, 1000,  371,  766,  766, 1000,  766, 1000,
     1000,  766,  164,  164,  164,  164,  164,  164,  164,  172,
      172,  172,  172,  172,  172,  172,  186, 1000, 1000,  186,
      423,  423, 1000,  423,  423,  423,  423,  240,  240,  240,
      240,  240,  240,  240,  244,  244,  244,  244,  244,  244,
      244,  347,  347, 1000, 1000,  347,  347,  344,  344, 1000,

     1000,  344,  344,  752,  752, 1000, 1000,  752,   31, 1000,
     1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000,
     1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000,
     1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000,
     1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000,
     1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000,
     1000, 1000, 1000
    } ;

static yyconst flex_int16_t yy_chk[6464] =
    {   0,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    3,    3,    3,    3,    3,    3,
        3,    3,    3,    3,    3,    3,    3,    3,    3,    3,
        3,    3,    3,    3,    3,    3,    3,    3,    3,    3,
        3,    3,    3,    3,    3,    3,    3,    3,    3,    3,
        3,    3,    3,    3,    3,    3,    3,    3,    3,    3,

        3,    3,    3,    3,    3,    3,    3,    3,    5,  940,
        5,    5,    6,  132,    6,    6,    7,    7,   71,    7,
        8,    8,    7,    8,    7,   17,    8,   17,    8,    7,
       18,   71,   18,    8,   77,   77,  132,   21,   71,   21,
       21,  350,   34,  229,   34,   34,    5,   77,  350,   22,
        6,   22,   22,    5,   82,   82,  229,    6,   36,    5,
       36,   36,   79,    6,   11,  173,   11,   82,   11,   55,
       11,   55,   55,   79,   11,   79,   11,   79,   11,  117,
       21,   11,  173,   11,   11,   12,  115,   12,   21,   12,
      117,   12,   22,   34,  481,   12,  115,   12,  481,   12,

       22,   55,   12,  173,   12,   12,   19,   19,   19,   19,
       19,   19,   19,   19,   19,   19,   19,   19,   19,   19,
       19,   19,   19,   19,   19,   19,   19,   19,   19,   19,
       19,   19,   19,   19,   19,   19,   19,   19,   19,   19,
       19,   19,   19,   19,   19,   19,   19,   19,   19,   19,
       19,   19,   19,   19,   19,   19,   19,   19,   19,   19,
       23,   23,   23,   23,   23,   23,   23,   23,   23,   23,
       23,   23,   23,   23,   23,   23,   23,   23,   23,   23,
       23,   23,   23,   23,   23,   23,   23,   23,   23,   23,
       23,   23,   23,   23,   23,   23,   23,   23,   23,   23,

       23,   23,   23,   23,   23,   23,   23,   23,   23,   23,
       23,   23,   23,   23,   25,   25,   25,   25,   26,   26,
       26,   26,   29,  476,   29,   29,   30,   72,   30,   30,
       72,   38,  116,   38,   38,   25,   73,  192,  192,   26,
      882,   85,  116,   72,  476,   39,   73,   39,   39,   73,
       85,   29,   85,   39,   85,   30,   41,   25,   41,   41,
       43,   26,   43,   43,   29,   25,  129,   29,   30,   26,
      352,   30,   43,   29,   75,  352,  129,   30,   33,   33,
       33,   33,   38,  131,   75,   33,   33,   75,  130,   33,
       33,   33,   33,   33,  131,   33,   39,  614,  130,   33,

       33,   33,   33,   56,  353,   56,   56,   41,  614,  235,
       44,   43,   44,   44,   45,  368,   45,   45,   46,  353,
       46,   46,  235,  368,   33,   56,  383,   78,   33,   33,
       33,   37,   48,  383,   48,   48,   57,   78,   57,   57,
       78,  870,  245,   78,   37,   37,  268,  268,   47,   48,
       47,   37,   37,   37,   37,   37,   37,   40,   57,  245,
       47,   44,   47,   47,  537,   45,   40,   40,  162,   46,
      162,  162,  537,   40,   40,   40,   40,   40,   40,   47,
      245,  379,  379,   48,   49,   49,   49,   49,   49,   49,
       49,   49,   49,   49,   49,   49,   49,   49,   49,   49,

       49,   49,   49,   49,   49,   49,   49,   49,   49,   49,
       49,   49,   49,   49,   49,   49,   49,   49,   49,   49,
       49,   49,   49,   49,   49,   49,   49,   49,   49,   49,
       49,   49,   49,   49,   49,   49,   49,   49,   51,  527,
       51,   51,   52,  868,   52,   52,   53,  532,   53,   53,
       54,  527,   54,   54,   58,  524,   58,   58,  275,  532,
       59,  524,   59,   59,   52,   52,   52,  862,   53,   53,
       53,  275,   54,   54,   54,   58,   59,   59,  860,   81,
       60,  282,   60,   60,   61,  387,   61,   61,   62,   51,
       62,   62,   81,   52,  282,   81,   87,   53,   87,   87,

      387,   54,   60,   60,   60,   63,   74,   63,   63,   76,
      526,   76,  526,   74,   80,   74,   84,   80,   76,   74,
       84,  818,   76,   86,   76,   74,   84,   86,   86,   84,
       80,   60,  787,   80,   83,   61,   86,   83,   83,   62,
       62,   88,   83,   88,   88,  118,  118,   87,   63,   91,
       83,   91,   91,  281,  786,  284,   63,   65,   91,   65,
       65,  118,  133,  133,   65,   65,  281,  281,  284,   65,
       65,  293,   65,   65,   65,   65,   65,   65,  133,   90,
       65,   90,   90,  784,  293,  276,   88,   92,  276,   92,
       92,  292,   88,   90,   93,  292,   93,   93,  276,   96,

       90,   96,   96,   94,  292,   94,   94,  542,   65,   65,
       66,   95,   94,   95,   95,   97,  542,   97,   97,   93,
       95,   96,  354,   66,   66,   94,  108,  354,  108,  108,
       66,   66,   66,   66,   66,   66,   67,   97,   92,  385,
       98,  783,   98,   98,  385,   67,   67,  108,   99,  108,
       99,   99,   67,   67,   67,   67,   67,   67,   68,  772,
       68,   68,   68,  388,   68,   68,   68,  286,  388,  771,
       68,   68,   98,   68,   68,   68,   68,   68,   68,   99,
      286,   68,  286,   68,   68,   68,   68,   68,   68,   68,
       68,   68,   68,   68,   68,   68,   68,   68,   68,   68,

       68,   68,   68,   68,   68,   68,   68,   68,  769,   68,
       68,   69,   69,   69,   69,   69,   69,   69,   69,   69,
       69,   69,   69,   69,   69,   69,   69,   69,   69,   69,
       69,   69,   69,   69,   69,   69,   69,   69,   69,   69,
       69,   69,   69,   69,   69,   69,   69,   69,   69,   69,
       69,   69,   69,   69,   69,   69,   69,   69,   69,   69,
       69,   69,   69,   69,   69,   70,  280,   70,   70,  273,
      695,  273,   70,   70,  273,  273,  280,   70,   70,  280,
       70,   70,   70,   70,   70,   70,  695,  100,   70,  100,
      100,  386,  101,   70,  101,  101,  102,  768,  102,  102,

      103,  101,  103,  103,  386,  543,   70,  104,  543,  104,
      104,  105,  100,  105,  105,  483,   70,   70,  106,  289,
      106,  106,  165,  107,  104,  107,  107,  102,  103,  104,
      289,  109,  289,  109,  109,  110,  483,  110,  110,  105,
      109,  427,  427,  165,  109,  107,  106,  111,  623,  111,
      111,  113,  110,  113,  112,  283,  112,  112,  804,  119,
      283,  119,  119,  113,  165,  113,  113,  278,  283,  111,
      112,  804,  112,  112,  278,  111,  121,  112,  121,  121,
      278,  122,  113,  122,  122,  125,  534,  125,  125,  623,
      534,  134,  121,  134,  134,  536,  750,  128,  121,  128,

      128,  125,  119,  125,  125,  112,  114,  536,  114,  114,
      119,  538,  529,  128,  529,  128,  128,  135,  135,  135,
      135,  540,  114,  538,  114,  114,  287,  287,  140,  114,
      140,  140,  122,  296,  296,  540,  125,  140,  135,  287,
      717,  142,  134,  142,  142,  128,  296,  163,  128,  163,
      163,  546,  142,  183,  114,  183,  183,  114,  123,  123,
      123,  123,  123,  546,  123,  123,  123,  713,  135,  123,
      123,  123,  123,  123,  123,  123,  123,  123,  706,  123,
      123,  123,  123,  123,  123,  123,  123,  123,  123,  123,
      123,  123,  123,  123,  123,  123,  123,  123,  123,  123,

      123,  123,  123,  123,  123,  123,  123,  123,  123,  123,
      123,  126,  298,  126,  126,  126,  141,  126,  141,  141,
      158,  544,  158,  158,  544,  298,  555,  126,  700,  126,
      126,  167,  298,  167,  167,  555,  167,  141,  175,  541,
      175,  175,  158,  158,  158,  541,  126,  175,  184,  167,
      184,  184,  194,  551,  194,  194,  175,  194,  194,  539,
      539,  551,  126,  127,  127,  127,  127,  127,  127,  127,
      127,  127,  127,  127,  127,  127,  127,  127,  127,  127,
      127,  127,  127,  127,  127,  127,  127,  127,  127,  127,
      127,  127,  127,  127,  127,  127,  127,  127,  127,  127,

      127,  127,  127,  127,  127,  127,  127,  127,  127,  127,
      127,  127,  127,  127,  127,  127,  127,  136,  547,  136,
      136,  138,  547,  138,  138,  139,  548,  139,  139,  144,
      548,  144,  144,  146,  290,  146,  146,  147,  552,  147,
      147,  149,  290,  149,  149,  147,  150,  290,  150,  150,
      552,  291,  151,  149,  151,  151,  152,  553,  152,  152,
      153,  553,  153,  153,  291,  294,  291,  154,  136,  154,
      154,  155,  138,  155,  155,  294,  139,  153,  294,  160,
      144,  160,  160,  161,  146,  161,  161,  550,  147,  154,
      154,  154,  149,  155,  155,  155,  168,  150,  168,  168,

      698,  550,  156,  151,  156,  156,  210,  152,  210,  210,
      299,  153,  169,  288,  169,  169,  288,  299,  154,  241,
      169,  554,  155,  299,  156,  156,  156,  554,  600,  288,
      160,  160,  694,  210,  161,  170,  600,  170,  170,  171,
      241,  171,  171,  592,  592,  297,  176,  168,  176,  176,
      616,  616,  303,  156,  166,  303,  166,  166,  297,  166,
      297,  241,  177,  169,  177,  177,  802,  208,  303,  208,
      208,  802,  166,  166,  177,  178,  647,  178,  178,  166,
      166,  166,  166,  166,  166,  179,  170,  179,  179,  712,
      171,  174,  208,  174,  174,  712,  180,  176,  180,  180,

      174,  181,  759,  181,  181,  182,  759,  182,  182,  174,
      174,  305,  211,  177,  211,  211,  174,  174,  174,  174,
      174,  174,  305,  186,  305,  186,  178,  620,  212,  211,
      212,  212,  756,  428,  428,  186,  179,  186,  186,  189,
      756,  189,  189,  190,  428,  190,  190,  180,  197,  304,
      197,  197,  181,  637,  637,  212,  182,  185,  185,  185,
      185,  185,  304,  185,  304,  185,  185,  185,  185,  185,
      185,  185,  185,  185,  185,  185,  185,  185,  185,  185,
      185,  185,  185,  187,  188,  187,  188,  188,  800,  198,
      189,  198,  198,  686,  190,  187,  800,  187,  187,  197,

      195,  188,  195,  195,  196,  686,  196,  196,  185,  185,
      185,  199,  187,  199,  199,  200,  754,  200,  200,  696,
      593,  307,  195,  195,  195,  754,  201,  196,  201,  201,
      202,  696,  202,  202,  307,  188,  307,  200,  200,  200,
      198,  203,  556,  203,  203,  204,  300,  204,  204,  300,
      205,  195,  205,  205,  206,  196,  206,  206,  209,  300,
      209,  209,  199,  591,  748,  591,  200,  204,  204,  204,
      748,  708,  207,  205,  207,  207,  213,  201,  213,  213,
      214,  202,  214,  214,  215,  708,  215,  215,  207,  533,
      207,  207,  203,  520,  520,  615,  204,  615,  213,  213,

      213,  205,  214,  214,  520,  206,  215,  215,  215,  209,
      216,  760,  216,  216,  217,  760,  217,  217,  221,  487,
      221,  221,  222,  207,  222,  222,  223,  213,  223,  223,
      758,  214,  758,  216,  216,  215,  230,  801,  230,  230,
      231,  801,  231,  231,  232,  480,  232,  232,  231,  233,
      701,  233,  233,  234,  699,  234,  234,  699,  709,  230,
      887,  216,  701,  231,  797,  217,  797,  232,  887,  221,
      221,  702,  233,  222,  709,  295,  234,  223,  228,  454,
      228,  228,  295,  702,  407,  228,  228,  705,  295,  295,
      228,  228,  406,  228,  236,  228,  236,  236,  228,  705,

      237,  228,  237,  237,  238,  808,  238,  238,  711,  808,
      239,  236,  239,  239,  301,  301,  243,  236,  243,  243,
      711,  243,  247,  755,  247,  247,  755,  301,  403,  228,
      228,  247,  885,  239,  243,  250,  810,  250,  250,  371,
      247,  251,  810,  251,  251,  315,  885,  315,  315,  251,
      252,  237,  252,  252,  253,  238,  253,  253,  250,  315,
      792,  792,  239,  242,  251,  242,  242,  258,  242,  258,
      258,  357,  254,  252,  254,  254,  263,  253,  263,  263,
      348,  242,  242,  256,  889,  256,  256,  889,  242,  242,
      242,  242,  242,  242,  246,  254,  246,  246,  345,  263,

      256,  344,  330,  246,  330,  330,  256,  261,  313,  261,
      261,  260,  246,  246,  322,  244,  322,  322,  258,  246,
      246,  246,  246,  246,  246,  248,  240,  248,  248,  330,
      261,  322,  248,  248,  306,  306,  226,  248,  248,  306,
      248,  264,  248,  264,  264,  248,  715,  306,  248,  264,
      265,  172,  265,  265,  271,  843,  271,  271,  715,  261,
      266,  843,  266,  266,  264,  267,  164,  267,  267,  272,
      157,  272,  272,  265,  881,  881,  248,  248,  249,   31,
      249,  249,  798,  266,  798,  249,  249,  809,  267,  809,
      249,  249,   28,  249,  249,  249,  249,  249,  249,   27,

      269,  249,  269,  269,  274,  271,  274,  274,  310,  883,
      310,  310,  277,   10,  277,  277,  316,  269,  316,  316,
      272,  883,  317,  269,  317,  317,  849,  274,    9,  249,
      249,  255,  849,  255,  255,  886,  886,    0,  255,  255,
      277,  317,    0,  255,  255,    0,  255,  255,  255,  255,
      255,  255,    0,  277,  255,  321,  274,  321,  321,  310,
      939,  939,  320,  277,  320,  320,  328,  316,  328,  328,
      323,    0,  323,  323,  962,  324,  962,  324,  324,  935,
      321,  328,  255,  255,  257,  257,  257,  257,  257,  323,
      257,  935,  257,  257,  257,  257,  257,  257,  257,  257,

      257,  324,  257,  257,  257,  257,  257,  257,  257,  257,
        0,  920,  966,  320,  257,    0,  327,  920,  327,  327,
      325,    0,  325,  325,  966,    0,    0,  326,    0,  326,
      326,  332,    0,  332,  332,  257,  257,  257,  259,  327,
      259,  259,  259,    0,  259,  259,  259,  325,  326,  325,
      259,  259,  332,  259,  259,  259,  259,  259,  259,    0,
        0,  259,    0,  259,  259,  259,  259,  259,  259,  259,
      259,  259,  259,  259,  259,  259,  259,  259,  259,  259,
      259,  259,  259,  259,  259,  259,  259,  259,    0,  259,
      259,  270,  270,  270,  270,  270,    0,  270,    0,  270,

      270,  270,  270,  270,  270,  270,  270,  270,  270,  270,
      270,  270,  270,  270,  270,  270,  270,  279,  967,  279,
      279,  285,    0,  285,  285,  302,    0,  302,  302,  329,
      967,  329,  329,  331,    0,  331,  331,  333,    0,  333,
      333,    0,  270,  270,  270,  279,    0,    0,  337,  285,
      337,  337,    0,  302,  334,  329,  334,  334,  279,    0,
        0,    0,  285,  331,    0,    0,  302,  333,  279,    0,
        0,  337,  285,    0,  334,  335,  302,  335,  335,  336,
        0,  336,  336,  338,    0,  338,  338,  339,    0,  339,
      339,    0,    0,    0,  335,  340,    0,  340,  340,    0,

        0,  341,  338,  341,  341,    0,    0,  336,  338,    0,
      340,  342,  339,  342,  342,  343,    0,  343,  343,  359,
        0,  359,  359,    0,    0,    0,  341,  349,    0,  349,
      349,  351,  359,  351,  351,    0,    0,  362,  343,  362,
      362,    0,    0,  365,  342,  365,  365,    0,  370,    0,
      370,  370,  378,    0,  378,  378,    0,    0,    0,  365,
      405,  365,  365,    0,    0,  405,  343,  347,    0,  347,
      347,  347,    0,  347,  443,  349,  443,  443,  349,  351,
        0,  405,  351,  347,    0,  347,  347,    0,  362,  366,
      347,  366,  366,  443,  365,  367,    0,  367,  367,  370,

        0,    0,  405,  378,    0,  366,  405,  366,  366,    0,
        0,  367,    0,  367,  367,    0,    0,    0,  347,  372,
      367,  372,  372,  373,    0,  373,  373,    0,    0,  374,
        0,  374,  374,    0,    0,  372,    0,  372,  372,  373,
      366,  373,  373,    0,    0,  374,  367,  374,  374,  400,
        0,  400,  400,  401,    0,  401,  401,    0,  402,    0,
      402,  402,  442,    0,  442,  442,    0,    0,  401,  400,
      372,    0,    0,    0,  373,  402,    0,    0,    0,  442,
      374,  375,  375,  375,  375,  375,  375,  375,  375,  375,
      375,  375,  375,  375,  375,  375,  375,  375,  375,  375,

      375,  375,  375,  375,  375,  375,  375,  375,  375,  375,
      375,  375,  375,  375,  375,  375,  375,  375,  375,  375,
      375,  375,  375,  375,  375,  375,  375,  375,  375,  375,
      375,  375,  375,  375,  375,  376,    0,  376,  376,  376,
      565,  376,  565,  565,  382,    0,  382,  382,    0,  565,
        0,  376,    0,  376,  376,    0,  384,    0,  384,  384,
      391,    0,  391,  391,  392,  392,  392,  392,  393,    0,
      393,  393,  396,    0,  396,  396,  399,    0,  399,  399,
        0,  414,    0,  414,  414,  392,  376,  377,    0,  377,
      377,  377,  382,  377,  404,  382,  404,  404,  444,    0,

      444,  444,    0,  377,  384,  377,  377,  384,    0,    0,
      455,  391,  455,  455,  444,  392,  404,  404,  404,  393,
      377,    0,    0,  396,    0,  409,  411,  399,  411,  411,
      409,  411,  414,  455,    0,    0,    0,    0,  377,  380,
      380,  380,  380,  380,  411,  380,  409,  380,  380,  380,
      380,  380,  380,  380,  380,  380,  380,  380,  380,  380,
      380,  380,  380,  380,  380,  415,  415,  409,  413,    0,
        0,  409,  422,  413,  422,  422,    0,  417,  417,    0,
        0,    0,  415,    0,  421,  421,    0,    0,    0,  413,
      380,  380,  380,  381,  417,  381,  381,  559,    0,  559,

      559,  421,  425,  415,  425,  425,  381,  415,  381,  381,
      413,  381,  381,    0,  413,  417,    0,    0,  419,  417,
      419,  419,  421,  422,    0,  559,  421,  419,  424,  429,
      424,  429,  429,    0,    0,  430,  419,  430,  430,    0,
      424,    0,  424,  424,  381,  408,    0,  408,  408,    0,
      408,    0,  429,  425,    0,    0,    0,  431,    0,  431,
      431,  424,    0,  408,  408,  432,    0,  432,  432,    0,
      408,  408,  408,  408,  408,  408,  410,    0,  410,  410,
      429,  410,  736,    0,  736,  736,  430,    0,  433,    0,
      433,  433,    0,  736,  410,  410,    0,  434,    0,  434,

      434,  410,  410,  410,  410,  410,  410,  412,  431,  412,
      412,  435,  412,  435,  435,  578,  432,  578,  578,  436,
        0,  436,  436,    0,    0,  412,  412,    0,  437,    0,
      437,  437,  412,  412,  412,  412,  412,  412,  416,  433,
      416,  416,  436,  578,    0,    0,    0,  416,  434,    0,
      438,    0,  438,  438,    0,    0,  416,  416,  560,    0,
      560,  560,  435,  416,  416,  416,  416,  416,  416,  418,
      436,  418,  418,  439,    0,  439,  439,    0,  418,  437,
      560,  457,    0,  457,  457,    0,    0,  418,  418,  457,
      458,    0,  458,  458,  418,  418,  418,  418,  418,  418,

      420,  438,  420,  420,  457,  478,    0,  478,  478,  420,
      478,    0,  726,  458,  726,  726,    0,    0,  420,  420,
        0,  726,    0,  478,  439,  420,  420,  420,  420,  420,
      420,  426,  426,  426,  426,  426,  426,  426,  426,  426,
      426,  426,  426,  426,  426,  426,  426,  426,  426,  426,
      426,  426,  426,  426,  426,  426,  426,  426,  426,  426,
      426,  426,  426,  426,  426,  426,  426,  426,  426,  426,
      426,  426,  426,  426,  426,  426,  426,  426,  426,  426,
      426,  426,  426,  426,  426,  440,    0,  440,  440,  441,
        0,  441,  441,  445,    0,  445,  445,  446,    0,  446,

      446,  447,    0,  447,  447,  448,    0,  448,  448,  449,
        0,  449,  449,    0,    0,  445,  445,  450,    0,  450,
      450,    0,  451,    0,  451,  451,    0,  448,  448,  448,
      452,    0,  452,  452,    0,  453,  440,  453,  453,  456,
      441,  456,  456,    0,  445,  451,  451,  459,  446,  459,
      459,  460,  447,  460,  460,  461,  448,  461,  461,  462,
      449,  462,  462,  463,    0,  463,  463,    0,  450,  464,
        0,  464,  464,  451,  460,  465,    0,  465,  465,    0,
        0,  452,  462,    0,    0,  466,  453,  466,  466,    0,
      456,    0,  464,  467,    0,  467,  467,  468,  459,  468,

      468,  469,  466,  469,  469,    0,  461,  470,  466,  470,
      470,    0,    0,    0,  463,  471,  467,  471,  471,  472,
        0,  472,  472,    0,    0,    0,  465,  473,    0,  473,
      473,  485,    0,  485,  485,    0,    0,    0,  471,  488,
      485,  488,  488,  489,    0,  489,  489,    0,  468,  485,
      473,  492,  469,  492,  492,    0,    0,  490,  470,  490,
      490,  491,  488,  491,  491,  490,  493,  471,  493,  493,
      472,  474,    0,  474,  474,  495,  474,  495,  495,    0,
      490,  474,    0,  494,  491,  494,  494,    0,    0,  493,
        0,  474,    0,  496,  489,  496,  496,  474,  495,    0,

        0,  497,  492,  497,  497,    0,    0,  498,    0,  498,
      498,    0,  499,    0,  499,  499,    0,  500,  474,  500,
      500,    0,  474,  475,  497,  475,  475,    0,  475,  499,
      581,    0,  581,  581,  494,  499,  561,    0,  561,  561,
      500,  475,  475,  501,  496,  501,  501,  581,  475,  475,
      475,  475,  475,  475,  477,  561,  477,  477,  498,  477,
        0,    0,    0,  503,    0,  503,  503,    0,  504,    0,
      504,  504,  477,  477,    0,  505,  504,  505,  505,  477,
      477,  477,  477,  477,  477,  479,  503,  479,  479,    0,
      479,  504,    0,  569,  501,  569,  569,  506,  505,  506,

      506,    0,    0,  479,  479,  507,  569,  507,  507,    0,
      479,  479,  479,  479,  479,  479,  482,    0,  482,  482,
      506,  562,    0,  562,  562,  482,    0,    0,  507,  516,
        0,  516,  516,    0,  482,  482,  508,    0,  508,  508,
        0,  482,  482,  482,  482,  482,  482,  484,  562,  484,
      484,    0,  516,  508,    0,    0,  484,    0,  564,  508,
      564,  564,    0,    0,    0,  484,  484,  509,    0,  509,
      509,    0,  484,  484,  484,  484,  484,  484,  486,    0,
      486,  486,  510,  564,  510,  510,  512,  486,  512,  512,
      511,    0,  511,  511,    0,    0,  486,  486,  515,    0,

      515,  515,    0,  486,  486,  486,  486,  486,  486,  502,
        0,  502,  502,  511,    0,    0,  502,  502,  509,    0,
        0,  502,  502,    0,  502,  518,  502,  518,  518,  502,
        0,    0,  502,  510,    0,    0,  519,  512,  519,  519,
        0,    0,  511,  518,  518,    0,    0,    0,  518,  515,
      567,    0,  567,  567,  519,  519,    0,    0,    0,  519,
      502,  502,  513,    0,  513,  513,  513,    0,  513,  513,
      513,    0,  567,    0,  513,  513,    0,  513,  513,  513,
      513,  513,  513,    0,    0,  513,    0,  513,  513,  513,
      513,  513,  513,  513,  513,  513,  513,  513,  513,  513,

      513,  513,  513,  513,  513,  513,  513,  513,  513,  513,
      513,  513,    0,  513,  513,  514,    0,  514,  514,  563,
        0,  563,  563,  566,    0,  566,  566,  570,    0,  570,
      570,  571,    0,  571,  571,    0,    0,    0,  514,    0,
      570,  572,    0,  572,  572,  573,  563,  573,  573,    0,
      566,    0,  571,  574,  572,  574,  574,    0,  573,    0,
        0,    0,    0,    0,    0,    0,  574,  514,  517,  517,
      517,  517,  517,  517,  517,  517,  517,  517,  517,  517,
      517,  517,  517,  517,  517,  517,  517,  517,  517,  517,
      517,  517,  517,  517,  517,  517,  517,  517,  517,  517,

      517,  517,  517,  517,  517,  517,  517,  517,  517,  517,
      517,  517,  517,  517,  517,  517,  517,  517,  517,  517,
      517,  517,  521,    0,  521,  521,  521,    0,  521,  521,
      521,    0,    0,    0,  521,  521,    0,  521,  521,  521,
      521,  521,  521,    0,    0,  521,    0,  521,  521,  521,
      521,  521,  521,  521,  521,  521,  521,  521,  521,  521,
      521,  521,  521,  521,  521,  521,  521,  521,  521,  521,
      521,  521,    0,  521,  521,  522,    0,  522,  522,    0,
      525,    0,  525,  525,    0,    0,    0,  528,    0,  528,
      528,    0,  530,    0,  530,  530,    0,  531,    0,  531,

      531,    0,    0,    0,  535,    0,  535,  535,  545,    0,
      545,  545,  549,    0,  549,  549,  522,  557,    0,  557,
      557,  558,    0,  558,  558,    0,  522,  523,  528,  523,
      523,  525,    0,  530,  523,  523,    0,    0,  528,  523,
      523,    0,  523,  530,  523,  535,    0,  523,  531,  545,
      523,  568,    0,  568,  568,  535,    0,    0,  575,  545,
      575,  575,  576,  549,  576,  576,    0,  577,  557,  577,
      577,  579,  558,  579,  579,    0,    0,  575,  523,  523,
      577,  580,    0,  580,  580,    0,    0,  576,  582,    0,
      582,  582,  583,    0,  583,  583,  584,    0,  584,  584,

        0,  720,  568,  720,  720,    0,  587,  580,  587,  587,
      589,    0,  589,  589,  594,    0,  594,  594,  595,  584,
      595,  595,  579,    0,  582,  583,  720,    0,  617,  587,
      617,  617,    0,  589,  595,  594,  595,  595,    0,  582,
      596,  617,  596,  596,    0,    0,    0,  584,  586,    0,
      586,  586,  586,    0,  586,    0,  596,  587,  596,  596,
      597,  589,  597,  597,  586,    0,  586,  586,    0,  595,
      598,  586,  598,  598,    0,    0,  597,    0,  597,  597,
        0,  605,    0,  605,  605,  586,  598,    0,  598,  598,
      599,  596,  599,  599,  601,    0,  601,  601,    0,  586,

      588,    0,  588,  588,    0,    0,  599,    0,  599,  599,
      601,  597,  601,  601,    0,    0,  588,    0,  588,  588,
        0,  598,    0,  588,  619,  599,  619,  619,  602,  588,
      602,  602,  605,  610,    0,  610,  610,  619,    0,    0,
      603,  599,  603,  603,  602,  601,  602,  602,    0,    0,
        0,  588,  590,    0,  590,  590,  603,    0,  603,  603,
        0,    0,  604,    0,  604,  604,    0,    0,  590,    0,
      590,  590,    0,    0,  611,  590,  611,  611,  604,  602,
      604,  604,    0,    0,  610,  590,  612,    0,  612,  612,
      611,  603,  611,  611,  618,    0,  618,  618,    0,  638,

        0,  638,  638,  590,    0,  613,    0,  613,  613,    0,
        0,  618,    0,  604,  606,    0,  606,  606,  606,    0,
      606,  613,    0,  613,  613,  611,  631,    0,  631,  631,
      606,  631,  606,  606,    0,    0,    0,  612,  613,  635,
        0,  635,  635,  639,  631,  639,  639,    0,  635,  636,
      638,  636,  641,    0,  641,  641,  613,  635,    0,    0,
        0,  636,    0,  636,  636,  606,  607,    0,  607,  607,
      607,  641,  607,  642,  636,  642,  642,  649,    0,  649,
      649,    0,  607,    0,  607,  607,  642,  655,    0,  655,
      655,    0,    0,  659,  639,  659,  659,    0,    0,  719,

      649,  719,  719,  607,  824,    0,  824,  824,    0,    0,
      655,    0,  719,  824,    0,    0,  659,  607,  608,  608,
      608,  608,  608,  608,  608,  608,  608,  608,  608,  608,
      608,  608,  608,  608,  608,  608,  608,  608,  608,  608,
      608,  608,  608,  608,  608,  608,  608,  608,  608,  608,
      608,  608,  608,  608,  608,  608,  608,  608,  608,  608,
      608,  608,  608,  608,  608,  608,  608,  608,  608,  608,
      608,  608,  609,  609,  609,  609,  609,    0,  609,    0,
      609,  609,  609,  609,  609,  609,  609,  609,  609,    0,
      609,  609,  609,  609,  609,  609,  609,  609,  673,    0,

      673,  673,  640,    0,  640,  640,  643,    0,  643,  643,
      644,    0,  644,  644,    0,    0,  645,    0,  645,  645,
        0,  673,    0,  609,  609,  609,  628,    0,  646,    0,
      646,  646,    0,  648,    0,  648,  648,    0,    0,  628,
      628,  650,    0,  650,  650,    0,  628,  628,  628,  628,
      628,  628,  629,  640,    0,    0,  723,  643,  723,  723,
      651,  644,  651,  651,    0,  629,  629,  645,  723,    0,
        0,    0,  629,  629,  629,  629,  629,  629,  630,  646,
      630,  630,    0,  630,  648,  652,    0,  652,  652,    0,
        0,  653,  650,  653,  653,    0,  630,  630,  679,    0,

      679,  679,    0,  630,  630,  630,  630,  630,  630,  632,
      654,  651,  654,  654,  656,    0,  656,  656,  632,  632,
      724,  679,  724,  724,    0,  632,  632,  632,  632,  632,
      632,  633,    0,  724,    0,  657,  652,  657,  657,    0,
      633,  633,  653,  658,    0,  658,  658,  633,  633,  633,
      633,  633,  633,  634,    0,  634,  634,  660,    0,  660,
      660,  654,  634,    0,  661,  656,  661,  661,    0,    0,
        0,  634,  634,  662,    0,  662,  662,    0,  634,  634,
      634,  634,  634,  634,  661,  663,  657,  663,  663,  672,
        0,  672,  672,    0,  658,  663,  667,    0,  667,  667,

      671,  667,  671,  671,  674,  663,  674,  674,  660,  671,
      721,    0,  721,  721,  667,  661,    0,  675,  671,  675,
      675,    0,    0,  676,  662,  676,  676,  677,    0,  677,
      677,  678,    0,  678,  678,    0,  663,  664,  721,  680,
      672,  680,  680,    0,  681,    0,  681,  681,    0,    0,
      664,  664,    0,    0,    0,  674,    0,  664,  664,  664,
      664,  664,  664,  665,  732,    0,  732,  732,  675,    0,
      683,    0,  683,  683,  676,    0,  665,  665,  677,    0,
        0,  732,  678,  665,  665,  665,  665,  665,  665,  666,
      680,  666,  666,    0,  666,  681,    0,    0,    0,  684,

        0,  684,  684,  685,    0,  685,  685,  666,  666,  725,
        0,  725,  725,    0,  666,  666,  666,  666,  666,  666,
      668,  683,  684,  687,    0,  687,  687,    0,  725,  668,
      668,  727,    0,  727,  727,    0,  668,  668,  668,  668,
      668,  668,  669,    0,    0,  688,    0,  688,  688,    0,
        0,  669,  669,  691,  685,  691,  691,  727,  669,  669,
      669,  669,  669,  669,  670,    0,  670,  670,  689,    0,
      689,  689,    0,  670,  687,  730,    0,  730,  730,    0,
        0,    0,  670,  670,    0,  763,  688,  763,  763,  670,
      670,  670,  670,  670,  670,  682,  688,  682,  682,  682,

      730,  682,  682,  682,  691,    0,  763,  682,  682,  689,
      682,  682,  682,  682,  682,  682,    0,    0,  682,  689,
      682,  682,  682,  682,  682,  682,  682,  682,  682,  682,
      682,  682,  682,  682,  682,  682,  682,  682,  682,  682,
      682,  682,  682,  682,  682,    0,  682,  682,  690,    0,
      690,  690,  692,    0,  692,  692,  693,    0,  693,  693,
      697,    0,  697,  697,  703,    0,  703,  703,  704,    0,
      704,  704,  707,    0,  707,  707,  710,    0,  710,  710,
      714,    0,  714,  714,  716,    0,  716,  716,  718,  690,
      718,  718,  722,  692,  722,  722,    0,    0,  728,  690,

      728,  728,    0,  692,    0,  703,    0,  693,    0,  704,
      729,  697,  729,  729,    0,  703,    0,  710,    0,  704,
        0,  714,    0,  707,    0,  716,    0,  710,    0,  729,
      733,  714,  733,  733,  731,  716,  731,  731,  734,  718,
      734,  734,  735,  722,  735,  735,    0,  731,  737,  728,
      737,  737,    0,    0,  738,  733,  738,  738,  739,    0,
      739,  739,  740,  734,  740,  740,    0,  738,  741,    0,
      741,  741,  742,  737,  742,  742,    0,    0,  743,  740,
      743,  743,    0,    0,  745,    0,  745,  745,    0,  749,
        0,  749,  749,  735,  751,  741,  751,  751,    0,  752,

        0,  752,  752,  753,    0,  753,  753,  745,    0,  739,
      757,    0,  757,  757,    0,  752,    0,  752,  752,  753,
        0,  753,  753,  742,  749,  761,    0,  761,  761,  743,
      744,    0,  744,  744,  744,  745,  744,    0,    0,  762,
      749,  762,  762,    0,    0,  751,  744,    0,  744,  744,
      752,    0,    0,  744,  753,    0,    0,    0,  761,  744,
        0,  757,  764,    0,  764,  764,  765,    0,  765,  765,
      774,    0,  774,  774,    0,  775,  761,  775,  775,    0,
        0,  744,  746,  764,  746,  746,    0,    0,    0,  776,
      762,  776,  776,  777,    0,  777,  777,    0,  746,    0,

      746,  746,    0,    0,  778,  746,  778,  778,  779,    0,
      779,  779,  780,    0,  780,  780,  781,  765,  781,  781,
      788,  774,  788,  788,    0,    0,  775,  746,  789,    0,
      789,  789,    0,  746,  747,    0,  747,  747,    0,  791,
      776,  791,  791,  793,  777,  793,  793,    0,    0,    0,
      747,    0,  747,  747,    0,  778,    0,  747,  794,  779,
      794,  794,  821,  780,  821,  821,    0,  781,    0,  747,
      795,  788,  795,  795,  796,    0,  796,  796,    0,  789,
        0,  799,    0,  799,  799,  747,  767,  821,  767,  767,
      791,  767,    0,  823,  793,  823,  823,    0,    0,  825,

        0,  825,  825,    0,  767,  767,    0,    0,    0,  794,
      823,  767,  767,  767,  767,  767,  767,  770,    0,  770,
      770,  795,  799,    0,    0,  796,  770,  825,  827,    0,
      827,  827,  799,    0,    0,  770,  770,    0,    0,    0,
        0,  827,  770,  770,  770,  770,  770,  770,  773,  773,
      773,  773,  773,  773,  773,  773,  773,  773,  773,  773,
      773,  773,  773,  773,  773,  773,  773,  773,  773,  773,
      773,  773,  773,  773,  773,  773,  773,  773,  773,  773,
      773,  773,  773,  773,  773,  773,  773,  773,  773,  773,
      773,  773,  773,  773,  773,  773,  773,  773,  773,  773,

      773,  773,  782,    0,  782,  782,  803,  782,  803,  803,
      828,    0,  828,  828,  826,    0,  826,  826,    0,    0,
      782,  782,  833,  828,  833,  833,    0,  782,  782,  782,
      782,  782,  782,  785,    0,  785,  785,    0,    0,  833,
        0,  805,  785,  805,  805,  826,  806,  803,  806,  806,
        0,  785,  785,  811,    0,  811,  811,  803,  785,  785,
      785,  785,  785,  785,  790,  790,  790,  790,  790,    0,
      790,    0,  790,  790,  790,  790,  790,  790,  790,  790,
      790,  807,  790,  807,  807,  790,  790,  790,  790,  790,
        0,    0,  805,  812,  790,  812,  812,  806,  813,    0,

      813,  813,    0,    0,  811,  814,    0,  814,  814,  815,
        0,  815,  815,    0,    0,  790,  790,  790,  816,    0,
      816,  816,  807,  817,    0,  817,  817,  819,    0,  819,
      819,    0,  807,  820,  812,  820,  820,    0,  822,  813,
      822,  822,    0,    0,  812,  829,  814,  829,  829,  813,
      830,    0,  830,  830,    0,  831,  814,  831,  831,  816,
      815,  832,    0,  832,  832,  834,  829,  834,  834,  816,
      835,    0,  835,  835,  817,  830,  831,  836,  819,  836,
      836,    0,    0,  835,  820,  837,    0,  837,  837,  822,
        0,  838,    0,  838,  838,  839,    0,  839,  839,  840,

        0,  840,  840,  841,    0,  841,  841,  857,    0,  857,
      857,    0,  832,  838,    0,  858,  834,  858,  858,    0,
      857,  839,  872,    0,  872,  872,    0,    0,  836,  873,
        0,  873,  873,    0,    0,    0,  837,  873,  901,    0,
      901,  901,  858,    0,  908,  872,  908,  908,    0,    0,
      840,  901,  873,  908,  841,  842,  842,  842,  842,  842,
      842,  842,  842,  842,  842,  842,  842,  842,  842,  842,
      842,  842,  842,  842,  842,  842,  842,  842,  842,  842,
      842,  842,  842,  842,  842,  842,  842,  842,  842,  842,
      842,  842,  842,  842,  842,  842,  842,  842,  842,  842,

      842,  842,  842,  842,  842,  842,  842,  842,  842,  844,
        0,  844,  844,  845,    0,  845,  845,  846,    0,  846,
      846,  847,    0,  847,  847,  848,    0,  848,  848,    0,
      850,    0,  850,  850,    0,    0,  852,    0,  852,  852,
      846,    0,    0,  874,  844,  874,  874,  875,  845,  875,
      875,    0,  902,    0,  902,  902,    0,    0,    0,  855,
      844,  855,  855,    0,  845,  850,  874,  902,  846,  852,
      875,  856,  847,  856,  856,  853,  848,  853,  853,    0,
        0,  850,  851,  851,  851,  851,  851,  852,  851,    0,
      851,  851,  851,  851,  851,  851,  851,  851,  851,  854,

      851,  854,  854,  851,  851,  851,  851,  851,  853,  864,
      855,  864,  864,  865,    0,  865,  865,    0,    0,    0,
      851,  866,  856,  866,  866,  876,  853,  876,  876,    0,
        0,    0,  854,  851,  851,  851,    0,    0,  877,    0,
      877,  877,  878,    0,  878,  878,    0,    0,  876,    0,
      854,  859,    0,  859,  859,  877,  859,    0,    0,    0,
      864,  877,    0,  879,  865,  879,  879,    0,    0,  859,
      859,  880,  866,  880,  880,    0,  859,  859,  859,  859,
      859,  859,  861,    0,  861,  861,  884,    0,  884,  884,
        0,  861,    0,  878,  880,  907,    0,  907,  907,    0,

      861,  861,    0,  888,    0,  888,  888,  861,  861,  861,
      861,  861,  861,  867,  879,  867,  867,  890,  867,  890,
      890,  907,    0,  880,    0,  891,    0,  891,  891,    0,
        0,  867,  867,  894,    0,  894,  894,  884,  867,  867,
      867,  867,  867,  867,  869,    0,  869,  869,  892,    0,
      892,  892,    0,  869,  888,  893,    0,  893,  893,    0,
        0,    0,  869,  869,    0,    0,  891,    0,  890,  869,
      869,  869,  869,  869,  869,  871,  891,  871,  871,    0,
        0,    0,  871,  871,  894,    0,    0,  871,  871,  892,
      871,  895,  871,  895,  895,  871,  893,    0,  871,  892,

      896,    0,  896,  896,    0,  897,  893,  897,  897,  898,
        0,  898,  898,  899,    0,  899,  899,  900,    0,  900,
      900,  903,    0,  903,  903,    0,  871,  871,  904,    0,
      904,  904,  905,  903,  905,  905,  906,    0,  906,  906,
        0,  904,  895,    0,  909,    0,  909,  909,    0,    0,
      910,  896,  910,  910,    0,  911,  897,  911,  911,    0,
      898,  909,    0,  912,  899,  912,  912,  913,  900,  913,
      913,    0,    0,  914,  912,  914,  914,  915,    0,  915,
      915,    0,  916,  905,  916,  916,  917,  906,  917,  917,
      918,    0,  918,  918,  921,    0,  921,  921,    0,    0,

        0,  910,  922,  916,  922,  922,  911,  923,    0,  923,
      923,    0,  924,  918,  924,  924,    0,  921,  913,  925,
        0,  925,  925,    0,  914,  922,    0,  926,  915,  926,
      926,  927,    0,  927,  927,    0,  928,  917,  928,  928,
        0,  918,  923,    0,  929,  921,  929,  929,  951,  928,
      951,  951,  945,  922,  945,  945,    0,  934,  923,  934,
      934,  929,    0,  924,  930,  930,    0,  951,    0,  945,
      925,  930,  930,  930,  930,  930,  930,    0,  926,  931,
      931,  936,  927,  936,  936,    0,  931,  931,  931,  931,
      931,  931,  932,  932,  937,    0,  937,  937,  934,  932,

      932,  932,  932,  932,  932,  933,  933,  938,  934,  938,
      938,    0,  933,  933,  933,  933,  933,  933,  941,    0,
      941,  941,  936,  942,    0,  942,  942,  943,    0,  943,
      943,  944,  936,  944,  944,  937,  946,    0,  946,  946,
      947,    0,  947,  947,  948,  937,  948,  948,  938,  949,
        0,  949,  949,  950,    0,  950,  950,    0,  938,  952,
        0,  952,  952,  953,    0,  953,  953,    0,  946,  941,
      952,    0,    0,  954,  942,  954,  954,    0,  943,  950,
        0,  955,  944,  955,  955,  956,    0,  956,  956,    0,
      957,  947,  957,  957,  958,  948,  958,  958,    0,    0,

      949,  959,    0,  959,  959,  960,    0,  960,  960,  961,
        0,  961,  961,  963,  953,  963,  963,    0,  964,  960,
      964,  964,    0,    0,  954,  965,  959,  965,  965,  958,
        0,  968,  955,  968,  968,  969,  956,  969,  969,    0,
      970,  957,  970,  970,  971,  958,  971,  971,  972,    0,
      972,  972,  973,    0,  973,  973,  974,    0,  974,  974,
      961,    0,  969,  975,  963,  975,  975,    0,  976,  964,
      976,  976,    0,    0,    0,  977,  965,  977,  977,    0,
        0,    0,  968,  978,    0,  978,  978,  979,    0,  979,
      979,  970,    0,    0,  980,  971,  980,  980,  977,  972,

      978,    0,    0,  973,  979,    0,  981,  974,  981,  981,
      982,    0,  982,  982,  975,  983,    0,  983,  983,  976,
      984,    0,  984,  984,    0,  985,  977,  985,  985,  986,
        0,  986,  986,    0,  987,  980,  987,  987,    0,    0,
      990,  983,  990,  990,    0,  980,  988,  981,  988,  988,
        0,  982,  989,    0,  989,  989,  991,  981,  991,  991,
        0,  982,  992,  989,  992,  992,  993,  988,  993,  993,
        0,  984,  994,    0,  994,  994,  985,    0,    0,  995,
      986,  995,  995,    0,    0,  987,  996,  994,  996,  996,
      997,  990,  997,  997,  998,    0,  998,  998,  999,    0,

      999,  999,    0,    0,    0,    0,    0,  991,    0,    0,
        0,    0,    0,  992,    0,    0,    0,  993,    0,    0,
        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
      995,    0,    0,    0,    0,    0,    0,  996,    0,    0,
        0,  997,    0,    0,    0,  998,    0,    0,    0,  999,
     1001,    0,    0, 1001, 1002, 1002, 1002, 1002, 1002, 1002,
     1002, 1003, 1003, 1003, 1003, 1003, 1003, 1003, 1004,    0,
        0, 1004, 1005, 1005, 1005,    0, 1005, 1005, 1006, 1006,
     1006, 1006, 1006, 1006, 1006, 1007, 1007, 1007, 1007, 1007,
     1007, 1007, 1008, 1008,    0,    0, 1008, 1008, 1009,    0,

        0, 1009, 1010, 1010,    0,    0, 1010, 1011, 1011,    0,
        0, 1011, 1012,    0,    0, 1012, 1013, 1013, 1013,    0,
     1013, 1013, 1014, 1014,    0,    0, 1014, 1015, 1015,    0,
        0, 1015, 1016, 1016,    0,    0, 1016, 1017, 1017,    0,
        0, 1017, 1018, 1018,    0,    0, 1018, 1019, 1019,    0,
        0, 1019, 1020, 1020,    0, 1020, 1020,    0, 1020, 1021,
     1021,    0, 1021, 1021,    0, 1021, 1022, 1022, 1022, 1022,
     1022, 1022, 1022, 1023, 1023, 1023, 1023, 1023, 1023, 1023,
     1024,    0,    0, 1024, 1025, 1025, 1025, 1025, 1025, 1025,
     1025, 1026, 1026, 1026, 1026, 1026, 1026, 1026, 1027, 1027,

        0,    0, 1027, 1027, 1028, 1028,    0,    0, 1028, 1028,
     1029, 1029,    0,    0, 1029, 1030, 1030,    0,    0, 1030,
     1031, 1031,    0,    0, 1031, 1032, 1032,    0,    0, 1032,
     1033, 1033,    0,    0, 1033, 1034, 1034,    0,    0, 1034,
     1035, 1035,    0,    0, 1035, 1036, 1036,    0, 1036,    0,
        0, 1036, 1037, 1037, 1037, 1037, 1037, 1037, 1037, 1038,
     1038, 1038, 1038, 1038, 1038, 1038, 1039,    0,    0, 1039,
     1040, 1040,    0, 1040, 1040, 1040, 1040, 1041, 1041, 1041,
     1041, 1041, 1041, 1041, 1042, 1042, 1042, 1042, 1042, 1042,
     1042, 1043, 1043,    0,    0, 1043, 1043, 1044, 1044,    0,

        0, 1044, 1044, 1045, 1045,    0,    0, 1045, 1000, 1000,
     1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000,
     1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000,
     1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000,
     1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000,
     1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000,
     1000, 1000, 1000
    } ;

extern int yy_flex_debug;
int yy_flex_debug = 0;

static yy_state_type *yy_state_buf=0, *yy_state_ptr=0;
static char *yy_full_match;
static int yy_lp;
#define REJECT \
{ \
*yy_cp = (yy_hold_char); /* undo effects of setting up yytext */ \
yy_cp = (yy_full_match); /* restore poss. backed-over text */ \
++(yy_lp); \
goto find_rule; \
}

#define yymore() yymore_used_but_not_detected
#define YY_MORE_ADJ 0
#define YY_RESTORE_YY_MORE_OFFSET
char *yytext;
#line 1 "./lexsrc.l"
#line 2 "./lexsrc.l"
/*
 *  The Regina Rexx Interpreter
 *  Copyright (C) 1992-1994  Anders Christensen <anders@pvv.unit.no>
 *
 *  This library is free software; you can redistribute it and/or
 *  modify it under the terms of the GNU Library General Public
 *  License as published by the Free Software Foundation; either
 *  version 2 of the License, or (at your option) any later version.
 *
 *  This library is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 *  Library General Public License for more details.
 *
 *  You should have received a copy of the GNU Library General Public
 *  License along with this library; if not, write to the Free
 *  Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */
/*
 * If you change this file the following has to be done:
 * - regenerate lexsrc.c using boojum: ~/flex-2.5.4/flex and the
 *   command from "make lexsrc"
 * - change the value of YY_BUF_SIZE to 101000 in lexsrc.c
 *   This value MUST be larger than BUFFERSIZE in rexx.h
 *   It is not set automatically because certain variables
 *   are defined with this value BEFORE rexx.h is included
 *   Increasing this value will slow down parsing a bit.
 *   This value will be blown away if you regenerate lexxsrc.c
 *   from this file.
 */

#include "rexx.h"
#include "yaccsrc.h"
#include "flexint.h"
#include <string.h>
#include <assert.h>
#include <errno.h>

#ifdef REXX_8BIT_SUPPORT
#include "iohandlers.h"
#define ASSERT(a)
#else
#define ASSERT(a) assert((a))
#endif

/* Define ASCII_0_TERMINATES_STRING if you want that ASCII-0 terminates
 * an input string. Normally this should not happen. Input strings are
 * terminated by a length encoding. The string {"", length=1} is invalid for
 * the lexer (ASCII-0 is not allowed) while {"", length=0} is allowed (this
 * is an empty input).
 * ASCII_0_TERMINATES_STRING is only(!) for backward compatibility and
 * shouldn't be used under normal circumstances.
 * FGC
 */
#define ASCII_0_TERMINATES_STRING

#ifdef YYLMAX
# undef YYLMAX
#endif
#define YYLMAX BUFFERSIZE

#ifdef FLEX_SCANNER
#undef YY_CHAR
#define YY_CHAR YY_CHAR_TYPE
#undef YY_INPUT
#define YY_INPUT(buf,result,max_size) result=fill_buffer(buf,max_size)
#endif

/* NOTE: Every comment is replaced by a '`' character in the lower input
 * routines. These should check for such (illegal) characters.
 */
#define MY_ISBLANK(c) (((c)==' ')||((c)=='\t')||((c)=='\v')||((c)=='\f')|| \
                       ((c)=='\r')||((c)=='`'))

PROTECTION_VAR(regina_parser)
/* externals which are protected by regina_parser */
internal_parser_type parser_data = {NULL, };
int retlength=0 ;
char retvalue[BUFFERSIZE] ;
unsigned SymbolDetect = 0;
/* end of externals protected by regina_parser */

/* locals, they are protected by regina_parser, too */
static int nextline = 1;
static int nextstart = 1;
static int do_level = 0 ;
static int in_numform=0, next_numform=0 ;
static int obs_with=0, in_do=0, in_then=0;
static int in_parse=0 ;
static int in_trace=0, itflag=0 ;
static int in_signal=0, in_call=0 ;
static enum { not_in_address = 0,
              in_address_keyword, /* ADDRESS just seen */
              in_address_main, /* after the first word */
              in_address_value, /* like main but VALUE was seen */
              in_address_with} in_address = not_in_address,
                               last_in_address = not_in_address ;
static enum {no_seek_with = 0,
             seek_with_from_parse,
             seek_with_from_address} seek_with = no_seek_with ;
/*
 * expression_ended is set if a typical expression has ended and the next
 * token has to be preceeded by a CONCATENATE (abuttal) operator in most
 * cases.
 */
static int expression_ended=0;

/*
 * insert_abuttal is set if the last token was a possible end of an expression.
 * The next token may need to be preceeded by an additional CONCATENATE
 * operator under some conditions like not being "in_parse".
 */
static int insert_abuttal=0;

/*
 * A symbol may be pending after a CONTATENATE (abuttal) operator has been
 * returned. This symbol will be stored here. 0 indicates no pending symbol.
 * ASCII 0 will never been returned, there is no need for another indicator.
 */
static int delayed_symbol=0;

/*
 * inhibit_delayed_abuttal can be set only if delayed_symbol has been set,
 * but not always. An opening parenthesis must have been detected, too.
 * It inhibits the use of a CONCATENATE (abuttal) operator after the staring
 * parenthesis. Examples:
 * CONCATENATE {var_symbol}     <-- needs a CONCATENATE, another {var_symbol}
 *                                  may follow.
 * CONCATENATE {var_symbol} "(" <-- needs a CONCATENATE, another {var_symbol}
 *                                  is an expression's start.
 */
static int inhibit_delayed_abuttal=0;

static char ch;
static int kill_this_space=0, kill_next_space=1 ;
static int extnextline = -1, extnextstart; /* for a delayed line increment */
static int linenr=1 ;
static int contline = 0;
static int inEOF=0 ;
static int singlequote=0, doblequote=0 ;
static int firstln=0 ;
static int bufptr=0 ;
/* Previous bug. 8-bits clean combined with EOF ==> need an int */
static int chbuffer[LOOKAHEAD] ;
static int ipretflag=0, cch=0 ;
static const char *interptr=NULL ;
static const char *last_interptr=NULL ;
static const char *interptrmax ;
static int cchmax = 0 ;

static YY_CHAR_TYPE *rmspc( YY_CHAR_TYPE *instr ) ;
static void set_assignment( char delim );
static int process_number_or_const( const char *text, int len );
static int process_hex_or_bin_string( char *text, int len, int base );
static void compress_string( char *dest, const char *src );
static int fill_buffer( char *buf, int max_size ) ;
#define SET_NEXTSTART() (nextstart += yyleng)

#define YY_FATAL_ERROR(s) exiterror( ERR_PROG_UNREADABLE, 1, s )


#line 178 "./lexsrc.l"
/*
 * ANSI 6.2.2 definitions (partially with extensions)
 */
/*
* sigh, we need the reversed classes. flex isn't smart
* enough to provide it.
* Added "0-9" to notGeneral... to fix bug 724390
*/
/*
* A comment is converted to a sequence of ` signs in the
* lower layer
*/
/*
* A number is a little bit different to detect signs in the
* exponent
*/
/*
* read ANSI 6.2.1.1 carefully. We have to check the chars
* after the exponent for notGeneralDot below.
*/
/*
* Allow characters for any token in string passed back to TRACE instruction
* Fixes bug 3564586.
*/
/*
* The list of keywords.
*/
#line 2534 "./lexsrc.c"

#define INITIAL 0
#define comm 1
#define signal 2
#define sgtype 3
#define procd 4
#define parse 5
#define then 6
#define with 7
#define numeric 8
#define do1 9
#define other 10
#define value1 11
#define ifcont 12
#define signame 13
#define nmform 14

#ifndef YY_NO_UNISTD_H
/* Special case for "unistd.h", since it is non-ANSI. We include it way
 * down here because we want the user's section 1 to have been scanned first.
 * The user has a chance to override it with an option.
 */
#include <unistd.h>
#endif

#ifndef YY_EXTRA_TYPE
#define YY_EXTRA_TYPE void *
#endif

static int yy_init_globals (void );

/* Accessor methods to globals.
   These are made visible to non-reentrant scanners for convenience. */

int yylex_destroy (void );

int yyget_debug (void );

void yyset_debug (int debug_flag  );

YY_EXTRA_TYPE yyget_extra (void );

void yyset_extra (YY_EXTRA_TYPE user_defined  );

FILE *yyget_in (void );

void yyset_in  (FILE * _in_str  );

FILE *yyget_out (void );

void yyset_out  (FILE * _out_str  );

yy_size_t yyget_leng (void );

char *yyget_text (void );

int yyget_lineno (void );

void yyset_lineno (int _line_number  );

/* Macros after this point can all be overridden by user definitions in
 * section 1.
 */

#ifndef YY_SKIP_YYWRAP
#ifdef __cplusplus
extern "C" int yywrap (void );
#else
extern int yywrap (void );
#endif
#endif

#ifndef YY_NO_UNPUT
    
    static void yyunput (int c,char *buf_ptr  );
    
#endif

#ifndef yytext_ptr
static void yy_flex_strncpy (char *,yyconst char *,int );
#endif

#ifdef YY_NEED_STRLEN
static int yy_flex_strlen (yyconst char * );
#endif

#ifndef YY_NO_INPUT

#ifdef __cplusplus
static int yyinput (void );
#else
static int input (void );
#endif

#endif

/* Amount of stuff to slurp up with each read. */
#ifndef YY_READ_BUF_SIZE
#ifdef __ia64__
/* On IA-64, the buffer size is 16k, not 8k */
#define YY_READ_BUF_SIZE 16384
#else
#define YY_READ_BUF_SIZE 8192
#endif /* __ia64__ */
#endif

/* Copy whatever the last rule matched to the standard output. */
#ifndef ECHO
/* This used to be an fputs(), but since the string might contain NUL's,
 * we now use fwrite().
 */
#define ECHO do { if (FWRITE( yytext, yyleng, 1, yyout )) {FFLUSH(yyout);} } while (0)
#endif

/* Gets input and stuffs it into "buf".  number of characters read, or YY_NULL,
 * is returned in "result".
 */
#ifndef YY_INPUT
#define YY_INPUT(buf,result,max_size) \
	if ( YY_CURRENT_BUFFER_LVALUE->yy_is_interactive ) \
		{ \
		int c = '*'; \
		size_t n; \
		for ( n = 0; n < max_size && \
			     (c = getc( yyin )) != EOF && c != '\n'; ++n ) \
			buf[n] = (char) c; \
		if ( c == '\n' ) \
			buf[n++] = (char) c; \
		if ( c == EOF && ferror( yyin ) ) \
			YY_FATAL_ERROR( "input in flex scanner failed" ); \
		result = n; \
		} \
	else \
		{ \
		errno=0; \
		while ( (result = fread(buf, 1, max_size, yyin))==0 && ferror(yyin)) \
			{ \
			if( errno != EINTR) \
				{ \
				YY_FATAL_ERROR( "input in flex scanner failed" ); \
				break; \
				} \
			errno=0; \
			clearerr(yyin); \
			} \
		}\
\

#endif

/* No semi-colon after return; correct usage is to write "yyterminate();" -
 * we don't want an extra ';' after the "return" because that will cause
 * some compilers to complain about unreachable statements.
 */
#ifndef yyterminate
#define yyterminate() return YY_NULL
#endif

/* Number of entries by which start-condition stack grows. */
#ifndef YY_START_STACK_INCR
#define YY_START_STACK_INCR 25
#endif

/* Report a fatal error. */
#ifndef YY_FATAL_ERROR
#define YY_FATAL_ERROR(msg) yy_fatal_error( msg )
#endif

/* end tables serialization structures and prototypes */

/* Default declaration of generated scanner - a define so the user can
 * easily add parameters.
 */
#ifndef YY_DECL
#define YY_DECL_IS_OURS 1

extern int yylex (void);

#define YY_DECL int yylex (void)
#endif /* !YY_DECL */

/* Code executed at the beginning of each rule, after yytext and yyleng
 * have been set up.
 */
#ifndef YY_USER_ACTION
#define YY_USER_ACTION
#endif

/* Code executed at the end of each rule. */
#ifndef YY_BREAK
#define YY_BREAK /*LINTED*/break;
#endif

#define YY_RULE_SETUP \
	YY_USER_ACTION

/** The main scanner function which does all the work.
 */
YY_DECL
{
	yy_state_type yy_current_state;
	char *yy_cp, *yy_bp;
	int yy_act;
    
	if ( !(yy_init) )
		{
		(yy_init) = 1;

#ifdef YY_USER_INIT
		YY_USER_INIT;
#endif

        /* Create the reject buffer large enough to save one state per allowed character. */
        if ( ! (yy_state_buf) )
            (yy_state_buf) = (yy_state_type *)yyalloc(YY_STATE_BUF_SIZE  );
            if ( ! (yy_state_buf) )
                YY_FATAL_ERROR( "out of dynamic memory in yylex()" );

		if ( ! (yy_start) )
			(yy_start) = 1;	/* first start state */

		if ( ! yyin )
			{yyin = stdin;yyin_io = yyin;}

		if ( ! yyout )
			{yyout = stdout;yyout_io=yyout;}

		if ( ! YY_CURRENT_BUFFER ) {
			yyensure_buffer_stack ();
			YY_CURRENT_BUFFER_LVALUE =
				yy_create_buffer( yyin, YY_BUF_SIZE );
		}

		yy_load_buffer_state(  );
		}

	{
#line 313 "./lexsrc.l"


   {
     if ( delayed_symbol )
     {
        int retval;
        retval = delayed_symbol;
        delayed_symbol = 0;
        /*
         * Pass the meaning of inhibit_delayed_abuttal to the normal algorithm
         * for automatic abuttal detection.
         */
        expression_ended = !inhibit_delayed_abuttal;
        inhibit_delayed_abuttal = 0;
        return retval;
     }

     if (next_numform)
     {
        in_numform = 1 ;
        next_numform = 0 ;
     }
     else
        in_numform = 0 ;

     last_in_address = in_address ; /* just for the "Environment" */
    /* there can't be an intermediate SPACE between ADDRESS and the next word*/
     if ( in_address == in_address_keyword )
        in_address = in_address_main ;

     kill_this_space = kill_next_space ;
     kill_next_space = 0 ;


     if (itflag)
     {
        in_trace = 0 ;
        seek_with = no_seek_with ;
     }
     itflag = (in_trace) ;

     if (extnextline != -1)
     {
        parser_data.tstart = nextstart = extnextstart;
        parser_data.tline = nextline = extnextline;
        extnextline = -1;
     }
     else
     {
        parser_data.tstart = nextstart ;
        parser_data.tline = nextline ;
     }
     insert_abuttal = expression_ended ;
     expression_ended = 0 ;
   }

#line 2829 "./lexsrc.c"

	while ( /*CONSTCOND*/1 )		/* loops until end-of-file is reached */
		{
		yy_cp = (yy_c_buf_p);

		/* Support of yytext. */
		*yy_cp = (yy_hold_char);

		/* yy_bp points to the position in yy_ch_buf of the start of
		 * the current run.
		 */
		yy_bp = yy_cp;

		yy_current_state = (yy_start);

		(yy_state_ptr) = (yy_state_buf);
		*(yy_state_ptr)++ = yy_current_state;

yy_match:
		do
			{
			YY_CHAR yy_c = yy_ec[YY_SC_TO_UI(*yy_cp)] ;
			while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
				{
				yy_current_state = (int) yy_def[yy_current_state];
				if ( yy_current_state >= 1001 )
					yy_c = yy_meta[(unsigned int) yy_c];
				}
			yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
			*(yy_state_ptr)++ = yy_current_state;
			++yy_cp;
			}
		while ( yy_base[yy_current_state] != 6409 );

yy_find_action:
		yy_current_state = *--(yy_state_ptr);
		(yy_lp) = yy_accept[yy_current_state];
find_rule: /* we branch to this label when backing up */
		for ( ; ; ) /* until we find what rule we matched */
			{
			if ( (yy_lp) && (yy_lp) < yy_accept[yy_current_state + 1] )
				{
				yy_act = yy_acclist[(yy_lp)];
					{
					(yy_full_match) = yy_cp;
					break;
					}
				}
			--yy_cp;
			yy_current_state = *--(yy_state_ptr);
			(yy_lp) = yy_accept[yy_current_state];
			}

		YY_DO_BEFORE_ACTION;

do_action:	/* This label is used only to access EOF actions. */

		switch ( yy_act )
	{ /* beginning of action switch */
case 1:
YY_RULE_SETUP
#line 369 "./lexsrc.l"
{
   SET_NEXTSTART() ; }
	YY_BREAK
case 2:
/* rule 2 can match eol */
YY_RULE_SETUP
#line 372 "./lexsrc.l"
{
   /*
    * Fixes bug 579597, "[;\r?\n]" instead of "{EOL}" causes the bug.
    */
   char *ptr;
   if ((ptr = strchr(yytext, '\n')) != NULL)
   {
      nextstart = yyleng - (int) (ptr - (char *) yytext) ;
      nextline++ ;
      if (extnextline != -1)
      {
         extnextline++;
         extnextstart = nextstart; /* fixes bug 938204 */
      }
   }
   else
      SET_NEXTSTART() ;
   return STATSEP ; }
	YY_BREAK
case 3:
/* rule 3 can match eol */
YY_RULE_SETUP
#line 391 "./lexsrc.l"
{
   char *ptr;
   BEGIN comm ;
   if ( obs_with )
   {
      parser_data.tline = linenr - 1 ; /* set tline for exiterror */
      exiterror( ERR_INVALID_TEMPLATE, 1, yytext )  ;
   }
   obs_with = in_do = 0 ;
   in_signal = in_call = 0 ;
   in_address = not_in_address;
   in_parse = 0 ;
   if ( seek_with == seek_with_from_address )
      seek_with = no_seek_with ;
   if ((ptr = strchr(yytext, '\n')) != NULL)
   {
      nextstart = yyleng - (int) (ptr - (char *) yytext) ;
      nextline++ ;
      if (extnextline != -1)
      {
         extnextline++;
         extnextstart = nextstart; /* fixes bug 938204 */
      }
   }
   else
      SET_NEXTSTART() ;
   return STATSEP ; }
	YY_BREAK
case 4:
/* rule 4 can match eol */
*yy_cp = (yy_hold_char); /* undo effects of setting up yytext */
YY_LINENO_REWIND_TO(yy_bp + 5);
(yy_c_buf_p) = yy_cp = yy_bp + 5;
YY_DO_BEFORE_ACTION; /* set up yytext again */
YY_RULE_SETUP
#line 419 "./lexsrc.l"
{
   int  i;
   char work[16];

   /* support C-like __LINE__ value */
   /* determine current source line, and create a numeric literal */

   parser_data.tline = linenr - 1 ; /* set tline for exiterror */

   sprintf (work, "%d", parser_data.tline);

   /* copy back work, right-to-left */

   for (i = strlen (work) - 1; i >= 0; i--)
   {
      unput (work[i]);
   }
}
	YY_BREAK
case 5:
YY_RULE_SETUP
#line 438 "./lexsrc.l"
{
   BEGIN value1 ; /* Allow a following VALUE keyword */
   seek_with = seek_with_from_address ;
   in_address = in_address_keyword ;
   in_call = 1 ; /* Allow the next words to be given as in CALL. */
   SET_NEXTSTART() ;
   return ADDRESS ; }
	YY_BREAK
case 6:
YY_RULE_SETUP
#line 446 "./lexsrc.l"
{
   BEGIN other ;
   in_parse = 1 ;
   SET_NEXTSTART() ;
   return ARG ; }
	YY_BREAK
case 7:
YY_RULE_SETUP
#line 452 "./lexsrc.l"
{
   BEGIN signal ;
   in_call = 1 ;
   SET_NEXTSTART() ;
   return CALL ; }
	YY_BREAK
case 8:
YY_RULE_SETUP
#line 458 "./lexsrc.l"
{
   BEGIN do1 ;
   ASSERT ( dolevel >=0 ) ;
   do_level++ ;
   in_do = 1 ;
   SET_NEXTSTART() ;
   return DO ; }
	YY_BREAK
case 9:
YY_RULE_SETUP
#line 466 "./lexsrc.l"
{
   BEGIN other ;
   in_parse = 1 ;
   SET_NEXTSTART() ;
   return DROP ; }
	YY_BREAK
case 10:
YY_RULE_SETUP
#line 472 "./lexsrc.l"
{
   BEGIN comm ;
   SET_NEXTSTART() ;
   return ELSE ; }
	YY_BREAK
case 11:
YY_RULE_SETUP
#line 477 "./lexsrc.l"
{
   BEGIN other ;
   SET_NEXTSTART() ;
   return EXIT ; }
	YY_BREAK
case 12:
YY_RULE_SETUP
#line 482 "./lexsrc.l"
{
   BEGIN ifcont ;
   in_then = 1 ;
   parser_data.if_linenr = linenr - 1;
   SET_NEXTSTART() ;
   return IF ; }
	YY_BREAK
case 13:
YY_RULE_SETUP
#line 489 "./lexsrc.l"
{
   BEGIN other ;
   SET_NEXTSTART() ;
   return INTERPRET ; }
	YY_BREAK
case 14:
YY_RULE_SETUP
#line 494 "./lexsrc.l"
{
   BEGIN other ;
   SET_NEXTSTART() ;
   return ITERATE ; }
	YY_BREAK
case 15:
YY_RULE_SETUP
#line 499 "./lexsrc.l"
{
   BEGIN other ;
   SET_NEXTSTART() ;
   return LEAVE ; }
	YY_BREAK
case 16:
YY_RULE_SETUP
#line 504 "./lexsrc.l"
{
   BEGIN other ;
   SET_NEXTSTART() ;
   return OPTIONS ; }
	YY_BREAK
case 17:
YY_RULE_SETUP
#line 509 "./lexsrc.l"
{
   BEGIN other ;
   SET_NEXTSTART() ;
   return NOP ; }
	YY_BREAK
case 18:
YY_RULE_SETUP
#line 514 "./lexsrc.l"
{
   BEGIN numeric ;
   SET_NEXTSTART() ;
   return NUMERIC ; }
	YY_BREAK
case 19:
YY_RULE_SETUP
#line 519 "./lexsrc.l"
{
   BEGIN parse ;
   in_parse = 1 ;
   SET_NEXTSTART() ;
   return PARSE ; }
	YY_BREAK
case 20:
YY_RULE_SETUP
#line 525 "./lexsrc.l"
{
   BEGIN procd ;
   SET_NEXTSTART() ;
   return PROCEDURE ; }
	YY_BREAK
case 21:
YY_RULE_SETUP
#line 530 "./lexsrc.l"
{
   BEGIN other ;
   in_parse = 1 ;
   SET_NEXTSTART() ;
   return PULL ; }
	YY_BREAK
case 22:
YY_RULE_SETUP
#line 536 "./lexsrc.l"
{
   BEGIN other ;
   SET_NEXTSTART() ;
   return PUSH ; }
	YY_BREAK
case 23:
YY_RULE_SETUP
#line 541 "./lexsrc.l"
{
   BEGIN other ;
   SET_NEXTSTART() ;
   return QUEUE ; }
	YY_BREAK
case 24:
YY_RULE_SETUP
#line 546 "./lexsrc.l"
{
   BEGIN other ;
   SET_NEXTSTART() ;
   return RETURN ; }
	YY_BREAK
case 25:
YY_RULE_SETUP
#line 551 "./lexsrc.l"
{
   BEGIN other ;
   SET_NEXTSTART() ;
   return SAY ; }
	YY_BREAK
case 26:
YY_RULE_SETUP
#line 556 "./lexsrc.l"
{
   BEGIN other ;
   ASSERT ( dolevel >= 0 ) ;
   do_level++ ; parser_data.select_linenr = linenr - 1;
   SET_NEXTSTART() ;
   return SELECT ; }
	YY_BREAK
case 27:
YY_RULE_SETUP
#line 563 "./lexsrc.l"
{
   BEGIN signal ;
   in_signal = 1 ;
   SET_NEXTSTART() ;
   return SIGNAL ; }
	YY_BREAK
case 28:
YY_RULE_SETUP
#line 569 "./lexsrc.l"
{
   BEGIN value1 ;
   in_trace = 1 ;
   SET_NEXTSTART() ;
   return TRACE ; }
	YY_BREAK
case 29:
YY_RULE_SETUP
#line 575 "./lexsrc.l"
{
   BEGIN other ;
   in_parse = 1 ;
   SET_NEXTSTART() ;
   return UPPER ; }
	YY_BREAK
case 30:
YY_RULE_SETUP
#line 581 "./lexsrc.l"
{
   BEGIN ifcont ;
   in_then = 1 ;
   parser_data.when_linenr = linenr - 1;
   SET_NEXTSTART() ;
   return WHEN ; }
	YY_BREAK
case 31:
YY_RULE_SETUP
#line 588 "./lexsrc.l"
{
   BEGIN comm ;
   SET_NEXTSTART() ;
   return OTHERWISE ; }
	YY_BREAK
case 32:
YY_RULE_SETUP
#line 593 "./lexsrc.l"
{
   BEGIN other ;
   ASSERT ( dolevel >= 0 ) ;
   if ( !do_level )
   {
      parser_data.tline = linenr - 1 ; /* set tline for exiterror */
      exiterror( ERR_UNMATCHED_END, 1 ) ;
   }
   do_level-- ;
   SET_NEXTSTART() ;
   return END ; }
	YY_BREAK
case 33:
YY_RULE_SETUP
#line 605 "./lexsrc.l"
{
   if (in_parse)
   {
      SET_NEXTSTART() ;
      return yylex() ;
   }
   else
      REJECT ; }
	YY_BREAK
case 34:
YY_RULE_SETUP
#line 614 "./lexsrc.l"
{
   if (in_parse)
   {
      SET_NEXTSTART() ;
      return PLACEHOLDER ;
   }
   else
   {
      REJECT ;
   }
 }
	YY_BREAK
case 35:
YY_RULE_SETUP
#line 626 "./lexsrc.l"
{
   /* .var = */
   parser_data.tline = linenr - 1 ; /* set tline for exiterror */
   if ( yytext[0] == '.' )
   {
      set_assignment( '=' );
      /*
       * FIXME, FGC: ANSI 6.2.3.1 forces an error 50.1 if yytext[0]=='.'
       *             ANSI 6.3.2.8 forces this error 31.3 which is wrong
       *             in its content.
       *             We use 6.2.3.1
       */
      if ( !KNOWN_RESERVED( retvalue, retlength ) )
      {
         yytext[retlength] = '\0';
         exiterror( ERR_RESERVED_SYMBOL, 1, yytext );
      }
      else
      {
         yytext[retlength] = '\0';
         exiterror( ERR_INVALID_START, 3, yytext );
      }
   }
   else
   {
      yytext[retlength] = '\0';
      exiterror( ERR_INVALID_START, 2, yytext );
   }
   /* known reserved variable */
   SET_NEXTSTART() ;
   return ASSIGNMENTVARIABLE ; }
	YY_BREAK
case 36:
YY_RULE_SETUP
#line 658 "./lexsrc.l"
{
   /* var = */
   BEGIN other ;

   set_assignment( '=' );

   SET_NEXTSTART() ;
   return ASSIGNMENTVARIABLE ; }
	YY_BREAK
case 37:
YY_RULE_SETUP
#line 667 "./lexsrc.l"
{
   /* .var += */
   parser_data.tline = linenr - 1 ; /* set tline for exiterror */
   if ( yytext[0] == '.' )
   {
      set_assignment( '+' );
      /*
       * FIXME, FGC: ANSI 6.2.3.1 forces an error 50.1 if yytext[0]=='.'
       *             ANSI 6.3.2.8 forces this error 31.3 which is wrong
       *             in its content.
       *             We use 6.2.3.1
       */
      if ( !KNOWN_RESERVED( retvalue, retlength ) )
      {
         yytext[retlength] = '\0';
         exiterror( ERR_RESERVED_SYMBOL, 1, yytext );
      }
      else
      {
         yytext[retlength] = '\0';
         exiterror( ERR_INVALID_START, 3, yytext );
      }
   }
   else
   {
      yytext[retlength] = '\0';
      exiterror( ERR_INVALID_START, 2, yytext );
   }
   /* known reserved variable */
   SET_NEXTSTART() ;
   return PLUSASSIGNMENTVARIABLE ; }
	YY_BREAK
case 38:
YY_RULE_SETUP
#line 699 "./lexsrc.l"
{
   /* var += */
   BEGIN other ;

   set_assignment( '+' );

   SET_NEXTSTART() ;
   return PLUSASSIGNMENTVARIABLE ; }
	YY_BREAK
case 39:
YY_RULE_SETUP
#line 708 "./lexsrc.l"
{
   /* .var -= */
   parser_data.tline = linenr - 1 ; /* set tline for exiterror */
   if ( yytext[0] == '.' )
   {
      set_assignment( '-' );
      /*
       * FIXME, FGC: ANSI 6.2.3.1 forces an error 50.1 if yytext[0]=='.'
       *             ANSI 6.3.2.8 forces this error 31.3 which is wrong
       *             in its content.
       *             We use 6.2.3.1
       */
      if ( !KNOWN_RESERVED( retvalue, retlength ) )
      {
         yytext[retlength] = '\0';
         exiterror( ERR_RESERVED_SYMBOL, 1, yytext );
      }
      else
      {
         yytext[retlength] = '\0';
         exiterror( ERR_INVALID_START, 3, yytext );
      }
   }
   else
   {
      yytext[retlength] = '\0';
      exiterror( ERR_INVALID_START, 2, yytext );
   }
   /* known reserved variable */
   SET_NEXTSTART() ;
   return MINUSASSIGNMENTVARIABLE ; }
	YY_BREAK
case 40:
YY_RULE_SETUP
#line 740 "./lexsrc.l"
{
   /* var -= */
   BEGIN other ;

   set_assignment( '-' );

   SET_NEXTSTART() ;
   return MINUSASSIGNMENTVARIABLE ; }
	YY_BREAK
case 41:
YY_RULE_SETUP
#line 749 "./lexsrc.l"
{
   /* .var *= */
   parser_data.tline = linenr - 1 ; /* set tline for exiterror */
   if ( yytext[0] == '.' )
   {
      set_assignment( '*' );
      /*
       * FIXME, FGC: ANSI 6.2.3.1 forces an error 50.1 if yytext[0]=='.'
       *             ANSI 6.3.2.8 forces this error 31.3 which is wrong
       *             in its content.
       *             We use 6.2.3.1
       */
      if ( !KNOWN_RESERVED( retvalue, retlength ) )
      {
         yytext[retlength] = '\0';
         exiterror( ERR_RESERVED_SYMBOL, 1, yytext );
      }
      else
      {
         yytext[retlength] = '\0';
         exiterror( ERR_INVALID_START, 3, yytext );
      }
   }
   else
   {
      yytext[retlength] = '\0';
      exiterror( ERR_INVALID_START, 2, yytext );
   }
   /* known reserved variable */
   SET_NEXTSTART() ;
   return MULTASSIGNMENTVARIABLE ; }
	YY_BREAK
case 42:
YY_RULE_SETUP
#line 781 "./lexsrc.l"
{
   /* var *= */
   BEGIN other ;

   set_assignment( '*' );

   SET_NEXTSTART() ;
   return MULTASSIGNMENTVARIABLE ; }
	YY_BREAK
case 43:
YY_RULE_SETUP
#line 790 "./lexsrc.l"
{
   /* .var /= */
   parser_data.tline = linenr - 1 ; /* set tline for exiterror */
   if ( yytext[0] == '.' )
   {
      set_assignment( '/' );
      /*
       * FIXME, FGC: ANSI 6.2.3.1 forces an error 50.1 if yytext[0]=='.'
       *             ANSI 6.3.2.8 forces this error 31.3 which is wrong
       *             in its content.
       *             We use 6.2.3.1
       */
      if ( !KNOWN_RESERVED( retvalue, retlength ) )
      {
         yytext[retlength] = '\0';
         exiterror( ERR_RESERVED_SYMBOL, 1, yytext );
      }
      else
      {
         yytext[retlength] = '\0';
         exiterror( ERR_INVALID_START, 3, yytext );
      }
   }
   else
   {
      yytext[retlength] = '\0';
      exiterror( ERR_INVALID_START, 2, yytext );
   }
   /* known reserved variable */
   SET_NEXTSTART() ;
   return DIVASSIGNMENTVARIABLE ; }
	YY_BREAK
case 44:
YY_RULE_SETUP
#line 822 "./lexsrc.l"
{
   /* var /= */
   BEGIN other ;

   set_assignment( '/' );

   SET_NEXTSTART() ;
   return DIVASSIGNMENTVARIABLE ; }
	YY_BREAK
case 45:
YY_RULE_SETUP
#line 831 "./lexsrc.l"
{
   /* .var %= */
   parser_data.tline = linenr - 1 ; /* set tline for exiterror */
   if ( yytext[0] == '.' )
   {
      set_assignment( '%' );
      /*
       * FIXME, FGC: ANSI 6.2.3.1 forces an error 50.1 if yytext[0]=='.'
       *             ANSI 6.3.2.8 forces this error 31.3 which is wrong
       *             in its content.
       *             We use 6.2.3.1
       */
      if ( !KNOWN_RESERVED( retvalue, retlength ) )
      {
         yytext[retlength] = '\0';
         exiterror( ERR_RESERVED_SYMBOL, 1, yytext );
      }
      else
      {
         yytext[retlength] = '\0';
         exiterror( ERR_INVALID_START, 3, yytext );
      }
   }
   else
   {
      yytext[retlength] = '\0';
      exiterror( ERR_INVALID_START, 2, yytext );
   }
   /* known reserved variable */
   SET_NEXTSTART() ;
   return INTDIVASSIGNMENTVARIABLE ; }
	YY_BREAK
case 46:
YY_RULE_SETUP
#line 863 "./lexsrc.l"
{
   /* var %= */
   BEGIN other ;

   set_assignment( '%' );

   SET_NEXTSTART() ;
   return INTDIVASSIGNMENTVARIABLE ; }
	YY_BREAK
case 47:
YY_RULE_SETUP
#line 872 "./lexsrc.l"
{
   /* .var //= */
   parser_data.tline = linenr - 1 ; /* set tline for exiterror */
   if ( yytext[0] == '.' )
   {
      set_assignment( '/' );
      /*
       * FIXME, FGC: ANSI 6.2.3.1 forces an error 50.1 if yytext[0]=='.'
       *             ANSI 6.3.2.8 forces this error 31.3 which is wrong
       *             in its content.
       *             We use 6.2.3.1
       */
      if ( !KNOWN_RESERVED( retvalue, retlength ) )
      {
         yytext[retlength] = '\0';
         exiterror( ERR_RESERVED_SYMBOL, 1, yytext );
      }
      else
      {
         yytext[retlength] = '\0';
         exiterror( ERR_INVALID_START, 3, yytext );
      }
   }
   else
   {
      yytext[retlength] = '\0';
      exiterror( ERR_INVALID_START, 2, yytext );
   }
   /* known reserved variable */
   SET_NEXTSTART() ;
   return MODULUSASSIGNMENTVARIABLE ; }
	YY_BREAK
case 48:
YY_RULE_SETUP
#line 904 "./lexsrc.l"
{
   /* var //= */
   BEGIN other ;

   set_assignment( '/' );

   SET_NEXTSTART() ;
   return MODULUSASSIGNMENTVARIABLE ; }
	YY_BREAK
case 49:
YY_RULE_SETUP
#line 913 "./lexsrc.l"
{
   /* .var |= */
   parser_data.tline = linenr - 1 ; /* set tline for exiterror */
   if ( yytext[0] == '.' )
   {
      set_assignment( '|' );
      /*
       * FIXME, FGC: ANSI 6.2.3.1 forces an error 50.1 if yytext[0]=='.'
       *             ANSI 6.3.2.8 forces this error 31.3 which is wrong
       *             in its content.
       *             We use 6.2.3.1
       */
      if ( !KNOWN_RESERVED( retvalue, retlength ) )
      {
         yytext[retlength] = '\0';
         exiterror( ERR_RESERVED_SYMBOL, 1, yytext );
      }
      else
      {
         yytext[retlength] = '\0';
         exiterror( ERR_INVALID_START, 3, yytext );
      }
   }
   else
   {
      yytext[retlength] = '\0';
      exiterror( ERR_INVALID_START, 2, yytext );
   }
   /* known reserved variable */
   SET_NEXTSTART() ;
   return ORASSIGNMENTVARIABLE ; }
	YY_BREAK
case 50:
YY_RULE_SETUP
#line 945 "./lexsrc.l"
{
   /* var |= */
   BEGIN other ;

   set_assignment( '|' );

   SET_NEXTSTART() ;
   return ORASSIGNMENTVARIABLE ; }
	YY_BREAK
case 51:
YY_RULE_SETUP
#line 954 "./lexsrc.l"
{
   /* .var &= */
   parser_data.tline = linenr - 1 ; /* set tline for exiterror */
   if ( yytext[0] == '.' )
   {
      set_assignment( '&' );
      /*
       * FIXME, FGC: ANSI 6.2.3.1 forces an error 50.1 if yytext[0]=='.'
       *             ANSI 6.3.2.8 forces this error 31.3 which is wrong
       *             in its content.
       *             We use 6.2.3.1
       */
      if ( !KNOWN_RESERVED( retvalue, retlength ) )
      {
         yytext[retlength] = '\0';
         exiterror( ERR_RESERVED_SYMBOL, 1, yytext );
      }
      else
      {
         yytext[retlength] = '\0';
         exiterror( ERR_INVALID_START, 3, yytext );
      }
   }
   else
   {
      yytext[retlength] = '\0';
      exiterror( ERR_INVALID_START, 2, yytext );
   }
   /* known reserved variable */
   SET_NEXTSTART() ;
   return ANDASSIGNMENTVARIABLE ; }
	YY_BREAK
case 52:
YY_RULE_SETUP
#line 986 "./lexsrc.l"
{
   /* var &= */
   BEGIN other ;

   set_assignment( '&' );

   SET_NEXTSTART() ;
   return ANDASSIGNMENTVARIABLE ; }
	YY_BREAK
case 53:
YY_RULE_SETUP
#line 995 "./lexsrc.l"
{
   /* .var &&= */
   parser_data.tline = linenr - 1 ; /* set tline for exiterror */
   if ( yytext[0] == '.' )
   {
      set_assignment( '&' );
      /*
       * FIXME, FGC: ANSI 6.2.3.1 forces an error 50.1 if yytext[0]=='.'
       *             ANSI 6.3.2.8 forces this error 31.3 which is wrong
       *             in its content.
       *             We use 6.2.3.1
       */
      if ( !KNOWN_RESERVED( retvalue, retlength ) )
      {
         yytext[retlength] = '\0';
         exiterror( ERR_RESERVED_SYMBOL, 1, yytext );
      }
      else
      {
         yytext[retlength] = '\0';
         exiterror( ERR_INVALID_START, 3, yytext );
      }
   }
   else
   {
      yytext[retlength] = '\0';
      exiterror( ERR_INVALID_START, 2, yytext );
   }
   /* known reserved variable */
   SET_NEXTSTART() ;
   return XORASSIGNMENTVARIABLE ; }
	YY_BREAK
case 54:
YY_RULE_SETUP
#line 1027 "./lexsrc.l"
{
   /* var &&= */
   BEGIN other ;

   set_assignment( '&' );

   SET_NEXTSTART() ;
   return XORASSIGNMENTVARIABLE ; }
	YY_BREAK
case 55:
YY_RULE_SETUP
#line 1036 "./lexsrc.l"
{
   /* .var ||= */
   parser_data.tline = linenr - 1 ; /* set tline for exiterror */
   if ( yytext[0] == '.' )
   {
      set_assignment( '|' );
      /*
       * FIXME, FGC: ANSI 6.2.3.1 forces an error 50.1 if yytext[0]=='.'
       *             ANSI 6.3.2.8 forces this error 31.3 which is wrong
       *             in its content.
       *             We use 6.2.3.1
       */
      if ( !KNOWN_RESERVED( retvalue, retlength ) )
      {
         yytext[retlength] = '\0';
         exiterror( ERR_RESERVED_SYMBOL, 1, yytext );
      }
      else
      {
         yytext[retlength] = '\0';
         exiterror( ERR_INVALID_START, 3, yytext );
      }
   }
   else
   {
      yytext[retlength] = '\0';
      exiterror( ERR_INVALID_START, 2, yytext );
   }
   /* known reserved variable */
   SET_NEXTSTART() ;
   return CONCATASSIGNMENTVARIABLE ; }
	YY_BREAK
case 56:
YY_RULE_SETUP
#line 1068 "./lexsrc.l"
{
   /* var ||= */
   BEGIN other ;

   set_assignment( '|' );

   SET_NEXTSTART() ;
   return CONCATASSIGNMENTVARIABLE ; }
	YY_BREAK
case 57:
YY_RULE_SETUP
#line 1077 "./lexsrc.l"
{
   if (in_call)
   {
      if ( ( last_in_address == in_address_keyword )
        && ( in_address == in_address_main ) )
      {
         BEGIN other ; /* the next useful expression will set it to "other"
                        * in either case. The BEGIN-states aren't very
                        * handy in most cases; they are not flexible enough.
                        */
         in_address = in_address_value ;
         in_call = 0;
         SET_NEXTSTART() ;
         return VALUE ;
      }
      REJECT ;
   }
   BEGIN other ;
   if ((!in_trace)&&(!in_address)&&(!in_signal)&&(!in_call)&&(!in_numform))
      obs_with = 1 ;
   in_trace = in_signal = in_call = 0 ;
   SET_NEXTSTART() ;
   return VALUE ; }
	YY_BREAK
case 58:
YY_RULE_SETUP
#line 1101 "./lexsrc.l"
{
   BEGIN sgtype ;
   SET_NEXTSTART() ;
   return ON ; }
	YY_BREAK
case 59:
YY_RULE_SETUP
#line 1106 "./lexsrc.l"
{
   BEGIN sgtype ;
   SET_NEXTSTART() ;
   return OFF ; }
	YY_BREAK
case 60:
YY_RULE_SETUP
#line 1111 "./lexsrc.l"
{
   BEGIN other ;
   SET_NEXTSTART() ;
   return NAME ; }
	YY_BREAK
case 61:
YY_RULE_SETUP
#line 1116 "./lexsrc.l"
{
   BEGIN signame ;
   SET_NEXTSTART() ;
   return ERROR ; }
	YY_BREAK
case 62:
YY_RULE_SETUP
#line 1121 "./lexsrc.l"
{
   BEGIN signame ;
   SET_NEXTSTART() ;
   return HALT ; }
	YY_BREAK
case 63:
YY_RULE_SETUP
#line 1126 "./lexsrc.l"
{
   BEGIN signame ;
   SET_NEXTSTART() ;
   return NOVALUE ; }
	YY_BREAK
case 64:
YY_RULE_SETUP
#line 1131 "./lexsrc.l"
{
   BEGIN signame ;
   SET_NEXTSTART() ;
   return NOTREADY ; }
	YY_BREAK
case 65:
YY_RULE_SETUP
#line 1136 "./lexsrc.l"
{
   BEGIN signame ;
   SET_NEXTSTART() ;
   return FAILURE ; }
	YY_BREAK
case 66:
YY_RULE_SETUP
#line 1141 "./lexsrc.l"
{
   BEGIN signame ;
   SET_NEXTSTART() ;
   return SYNTAX ; }
	YY_BREAK
case 67:
YY_RULE_SETUP
#line 1146 "./lexsrc.l"
{
   BEGIN signame ;
   SET_NEXTSTART() ;
   return LOSTDIGITS ; }
	YY_BREAK
case 68:
YY_RULE_SETUP
#line 1151 "./lexsrc.l"
{
   if (!in_trace) REJECT ;
   strcpy(retvalue,rmspc( yytext )) ;
   SET_NEXTSTART() ;
   return WHATEVER ; }
	YY_BREAK
case 69:
YY_RULE_SETUP
#line 1157 "./lexsrc.l"
{
   BEGIN other ;
   in_parse = 1 ;
   SET_NEXTSTART() ;
   return EXPOSE ; }
	YY_BREAK
case 70:
YY_RULE_SETUP
#line 1163 "./lexsrc.l"
{
   SET_NEXTSTART() ;
   return UPPER ; }
	YY_BREAK
case 71:
YY_RULE_SETUP
#line 1167 "./lexsrc.l"
{
   SET_NEXTSTART() ;
   return LOWER ; }
	YY_BREAK
case 72:
YY_RULE_SETUP
#line 1171 "./lexsrc.l"
{
   SET_NEXTSTART() ;
   return CASELESS ; }
	YY_BREAK
case 73:
YY_RULE_SETUP
#line 1175 "./lexsrc.l"
{
   BEGIN other ;
   SET_NEXTSTART() ;
   return ARG ; }
	YY_BREAK
case 74:
YY_RULE_SETUP
#line 1180 "./lexsrc.l"
{
   BEGIN other ;
   SET_NEXTSTART() ;
   return NUMERIC ; }
	YY_BREAK
case 75:
YY_RULE_SETUP
#line 1185 "./lexsrc.l"
{
   BEGIN other ;
   SET_NEXTSTART() ;
   return PULL ; }
	YY_BREAK
case 76:
YY_RULE_SETUP
#line 1190 "./lexsrc.l"
{
   BEGIN other ;
   SET_NEXTSTART() ;
   return SOURCE ; }
	YY_BREAK
case 77:
YY_RULE_SETUP
#line 1195 "./lexsrc.l"
{
   BEGIN other ;
   SET_NEXTSTART() ;
   return EXTERNAL ; }
	YY_BREAK
case 78:
YY_RULE_SETUP
#line 1200 "./lexsrc.l"
{
   BEGIN other ;
   SET_NEXTSTART() ;
   return LINEIN ; }
	YY_BREAK
case 79:
YY_RULE_SETUP
#line 1205 "./lexsrc.l"
{
   BEGIN other ;
   SET_NEXTSTART() ;
   return VERSION ; }
	YY_BREAK
case 80:
YY_RULE_SETUP
#line 1210 "./lexsrc.l"
{
   BEGIN other ;
   SET_NEXTSTART() ;
   return GUWNERIC ; }
	YY_BREAK
case 81:
YY_RULE_SETUP
#line 1215 "./lexsrc.l"
{
   BEGIN other ;
   in_parse = 2; /* accept a variable and treat func(a) as func (a) */
   SET_NEXTSTART() ;
   return VAR ; }
	YY_BREAK
case 82:
YY_RULE_SETUP
#line 1221 "./lexsrc.l"
{
   seek_with = seek_with_from_parse ;
   in_trace = 0 ;
   in_parse = 0 ;
   BEGIN with ; /* in fact this works as a "not comm" */
   SET_NEXTSTART() ;
   return VALUE ; }
	YY_BREAK
case 83:
YY_RULE_SETUP
#line 1229 "./lexsrc.l"
{
   in_then = 0 ;
   SET_NEXTSTART() ;
   return THEN ; }
	YY_BREAK
case 84:
YY_RULE_SETUP
#line 1234 "./lexsrc.l"
{
   if (in_then!=1) REJECT ;
   BEGIN comm ;
   in_then = 0 ;
   SET_NEXTSTART() ;
   return THEN ; }
	YY_BREAK
case 85:
YY_RULE_SETUP
#line 1241 "./lexsrc.l"
{
   /*
    * Fixes bug 952380
    */
   if ((in_do)||(!seek_with))
      REJECT ;
   BEGIN other ;
   if ( seek_with == seek_with_from_parse )
      in_parse = 1 ;
   seek_with = no_seek_with ;
   if (in_address) /* any address state */
      in_address = in_address_with ; /* WITH seen */
   SET_NEXTSTART() ;
   return WITH ; }
	YY_BREAK
case 86:
YY_RULE_SETUP
#line 1257 "./lexsrc.l"
{
   BEGIN other ;
   SET_NEXTSTART() ;
   return DIGITS ; }
	YY_BREAK
case 87:
YY_RULE_SETUP
#line 1262 "./lexsrc.l"
{
   BEGIN nmform ;
   next_numform = 1 ;
   SET_NEXTSTART() ;
   return FORM ; }
	YY_BREAK
case 88:
YY_RULE_SETUP
#line 1268 "./lexsrc.l"
{
   SET_NEXTSTART() ;
   return SCIENTIFIC ; }
	YY_BREAK
case 89:
YY_RULE_SETUP
#line 1272 "./lexsrc.l"
{
   SET_NEXTSTART() ;
   return ENGINEERING ; }
	YY_BREAK
case 90:
YY_RULE_SETUP
#line 1276 "./lexsrc.l"
{
   BEGIN other ;
   SET_NEXTSTART() ;
   return FUZZ ; }
	YY_BREAK
case 91:
YY_RULE_SETUP
#line 1281 "./lexsrc.l"
{
   BEGIN other ;
   assert(in_do) ;
   in_do = 2 ;
   SET_NEXTSTART() ;
   return FOREVER ; }
	YY_BREAK
case 92:
YY_RULE_SETUP
#line 1288 "./lexsrc.l"
{
   if ( in_do == 2 )
   {
      BEGIN other ;
      SET_NEXTSTART() ;
      return TO ;
   }
   else if ( in_do == 1 )
   {
      parser_data.tline = linenr - 1 ; /* set tline for exiterror */
      exiterror( ERR_INVALID_DO_SYNTAX, 1, "TO" )  ;
   }
   REJECT ; }
	YY_BREAK
case 93:
YY_RULE_SETUP
#line 1302 "./lexsrc.l"
{
   if ( in_do == 2 )
   {
      BEGIN other ;
      SET_NEXTSTART() ;
      return BY ;
   }
   else if ( in_do == 1 )
   {
      parser_data.tline = linenr - 1 ; /* set tline for exiterror */
      exiterror( ERR_INVALID_DO_SYNTAX, 1, "BY" ) ;
   }
   REJECT ; }
	YY_BREAK
case 94:
YY_RULE_SETUP
#line 1316 "./lexsrc.l"
{
   if ( in_do == 2 )
   {
      BEGIN other ;
      SET_NEXTSTART() ;
      return FOR ;
   }
   else if ( in_do == 1 )
   {
      parser_data.tline = linenr - 1 ; /* set tline for exiterror */
      exiterror( ERR_INVALID_DO_SYNTAX, 1, "FOR" ) ;
   }
   REJECT ; }
	YY_BREAK
case 95:
YY_RULE_SETUP
#line 1330 "./lexsrc.l"
{
   if (in_do)
   {
      if ( in_do == 3 )
      {
         parser_data.tline = linenr - 1 ; /* set tline for exiterror */
         exiterror( ERR_INVALID_DO_SYNTAX, 1, "WHILE" )  ;
      }
      in_do=3 ;
      BEGIN other ;
      SET_NEXTSTART() ;
      return WHILE ;
   }
   REJECT ; }
	YY_BREAK
case 96:
YY_RULE_SETUP
#line 1345 "./lexsrc.l"
{
   if (in_do) {
      if ( in_do == 3 )
      {
         parser_data.tline = linenr - 1 ; /* set tline for exiterror */
         exiterror( ERR_INVALID_DO_SYNTAX, 1, "UNTIL" )  ;
      }

      in_do=3 ;
      BEGIN other ;
      SET_NEXTSTART() ;
      return UNTIL ; }
   REJECT ; }
	YY_BREAK
case 97:
*yy_cp = (yy_hold_char); /* undo effects of setting up yytext */
(yy_c_buf_p) = yy_cp -= 1;
YY_DO_BEFORE_ACTION; /* set up yytext again */
YY_RULE_SETUP
#line 1360 "./lexsrc.l"
{
   BEGIN other ;
   in_do = 2 ;
   set_assignment( '=' );
   if ( !KNOWN_RESERVED( retvalue, retlength ) )
      exiterror( ERR_RESERVED_SYMBOL, 1, yytext )  ;
   SET_NEXTSTART() ;
   return DOVARIABLE ; }
	YY_BREAK
case 98:
*yy_cp = (yy_hold_char); /* undo effects of setting up yytext */
(yy_c_buf_p) = yy_cp -= 1;
YY_DO_BEFORE_ACTION; /* set up yytext again */
YY_RULE_SETUP
#line 1369 "./lexsrc.l"
{
   BEGIN other ;
   in_do = 2 ;
   strcpy(retvalue,rmspc( yytext )) ;
   SET_NEXTSTART() ;
   return DOVARIABLE ; }
	YY_BREAK
case 99:
YY_RULE_SETUP
#line 1376 "./lexsrc.l"
{
   unsigned i;
   BEGIN comm ;

   for( i = 0; ( ch = yytext[i] ) != '\0'; i++ )
   {
      /*
       * A blank or ':' can't occur in the normal text. They are terminators.
       */
      if ( ( ch == ':' )
        || ( ch == '\n' )
        || ( MY_ISBLANK( ch ) ) )
         break;
      retvalue[i] = (char) rx_toupper( ch );
   }
   retvalue[i] = '\0' ;
   SET_NEXTSTART() ;
   return LABEL ; }
	YY_BREAK
case 100:
/* rule 100 can match eol */
YY_RULE_SETUP
#line 1396 "./lexsrc.l"
{
   BEGIN comm ;

   compress_string( retvalue, yytext );

   SET_NEXTSTART() ;
   return LABEL ; }
	YY_BREAK
case 101:
/* rule 101 can match eol */
YY_RULE_SETUP
#line 1405 "./lexsrc.l"
{
   BEGIN other ;

   compress_string( retvalue, yytext );

   kill_next_space = 1 ;
   if ( insert_abuttal ) {
      inhibit_delayed_abuttal = 1 ;
      delayed_symbol = EXFUNCNAME ;
      SET_NEXTSTART() ;
      return CONCATENATE ; }

   expression_ended = 0 ;
   SET_NEXTSTART() ;
   return EXFUNCNAME ; }
	YY_BREAK
case 102:
/* rule 102 can match eol */
*yy_cp = (yy_hold_char); /* undo effects of setting up yytext */
YY_LINENO_REWIND_TO(yy_cp - 1);
(yy_c_buf_p) = yy_cp -= 1;
YY_DO_BEFORE_ACTION; /* set up yytext again */
YY_RULE_SETUP
#line 1423 "./lexsrc.l"
{
   /*
    * fixes bug 617225.
    */
   return process_hex_or_bin_string( yytext, yyleng, 16 ); }
	YY_BREAK
case 103:
/* rule 103 can match eol */
*yy_cp = (yy_hold_char); /* undo effects of setting up yytext */
YY_LINENO_REWIND_TO(yy_cp - 1);
(yy_c_buf_p) = yy_cp -= 1;
YY_DO_BEFORE_ACTION; /* set up yytext again */
YY_RULE_SETUP
#line 1431 "./lexsrc.l"
{
   return process_hex_or_bin_string( yytext, yyleng, 2 ); }
	YY_BREAK
case 104:
/* rule 104 can match eol */
*yy_cp = (yy_hold_char); /* undo effects of setting up yytext */
YY_LINENO_REWIND_TO(yy_cp - 1);
(yy_c_buf_p) = yy_cp -= 1;
YY_DO_BEFORE_ACTION; /* set up yytext again */
YY_RULE_SETUP
#line 1434 "./lexsrc.l"
{
   char c;
   int i,base,charcount,first,tuple;

   base = ( rx_toupper( yytext[yyleng - 1] ) == 'X' ) ? 16 : 2;
   parser_data.tline = linenr - 1 ; /* set tline for exiterror */
   /*
    * We are sure to have an invalid string since the above patterns won't
    * match. We can either have invalid characters or misplaced spaces.
    *
    * Blanks as the first characters are forbidden.
    */
   if ( MY_ISBLANK( yytext[1] ) )
      exiterror( ERR_INVALID_HEX_CONST, ( base == 16 ) ? 1 : 2, 1 );

   tuple = ( base == 16 ) ? 2 : 4;
   for ( i = 1, first = 1, charcount = 0; i < yyleng - 2; i++ )
   {
      c = yytext[i];
      if ( MY_ISBLANK( c ) )
      {
         /*
          * The first tuple may have less than tuple chars
          */
         if ( ( ( charcount % tuple ) == 0 ) || first )
         {
            first = 0;
            charcount = 0;
            continue;
         }
         exiterror( ERR_INVALID_HEX_CONST, ( base == 16 ) ? 1 : 2, i );
      }
      charcount++;
      if ( base == 2 )
      {
         if ( ( c == '0' ) || ( c == '1' ) )
            continue;
      }
      if ( base == 16 )
      {
         if ( rx_isxdigit( c ) )
            continue;
      }
      exiterror( ERR_INVALID_HEX_CONST, ( base == 16 ) ? 3 : 4, c );
   }
   /*
    * We didn't match something like "1 12 34 "X Assume this as the error.
    * Look back to the first blank in the last sequence.
    */
   for ( i = yyleng - 2; i > 1; i-- )
      if ( !MY_ISBLANK( yytext[i - 1] ) )
         break;
   exiterror( ERR_INVALID_HEX_CONST, ( base == 16 ) ? 1 : 2, i ); }
	YY_BREAK
case 105:
/* rule 105 can match eol */
YY_RULE_SETUP
#line 1488 "./lexsrc.l"
{
   BEGIN other ;

   compress_string( retvalue, yytext );

   strcpy( yytext, retvalue ); /* proper error display */

   if (in_numform)
   {
      parser_data.tline = linenr - 1 ; /* set tline for exiterror */
      exiterror( ERR_INV_SUBKEYWORD, 11, "ENGINEERING SCIENTIFIC", retvalue ) ;
   }

   /* fixes 1109372 */
   if ( insert_abuttal && !in_parse && !in_signal && !in_call ) {
      delayed_symbol = STRING ;
      SET_NEXTSTART() ;
      return CONCATENATE ; }

    if (in_call)
    {
       in_call = 0 ;
       kill_next_space = 1 ;
    }
    else
       expression_ended = 1 ;

   SET_NEXTSTART() ;
   return STRING ; }
	YY_BREAK
case 106:
YY_RULE_SETUP
#line 1519 "./lexsrc.l"
{
   if (!in_parse)
      REJECT ;
   strcpy(retvalue,yytext) ;
   SET_NEXTSTART() ;
   return OFFSET ; }
	YY_BREAK
case 107:
/* rule 107 can match eol */
*yy_cp = (yy_hold_char); /* undo effects of setting up yytext */
YY_LINENO_REWIND_TO(yy_cp - 1);
(yy_c_buf_p) = yy_cp -= 1;
YY_DO_BEFORE_ACTION; /* set up yytext again */
YY_RULE_SETUP
#line 1526 "./lexsrc.l"
{
   /*
    * This is the same as of the "{digit}+" rule above. flex is very stupid.
    * (Or is it a feature?)
    * The number below will take precedence instead of a plain "{digit}+",
    * even of the fact that the above rule may match the same length of
    * characters. flex seems to count the next "expect characters" for the
    * comparison which rule shall be used.
    */
   if (!in_parse)
      REJECT ;
   strcpy(retvalue,yytext) ;
   SET_NEXTSTART() ;
   return OFFSET ; }
	YY_BREAK
case 108:
/* rule 108 can match eol */
*yy_cp = (yy_hold_char); /* undo effects of setting up yytext */
YY_LINENO_REWIND_TO(yy_cp - 1);
(yy_c_buf_p) = yy_cp -= 1;
YY_DO_BEFORE_ACTION; /* set up yytext again */
YY_RULE_SETUP
#line 1541 "./lexsrc.l"
{
   /*
    * must split two rule parts because of the "/" rule-part.
    * This fixes bug 602283.
    */
   return process_number_or_const( yytext, yyleng );
}
	YY_BREAK
case 109:
YY_RULE_SETUP
#line 1549 "./lexsrc.l"
{
   return process_number_or_const( yytext, yyleng );
}
	YY_BREAK
case 110:
YY_RULE_SETUP
#line 1553 "./lexsrc.l"
{
   int i,j;
   /*
    * this might be a symbol in front of a function, but only if next
    * char in input stream is "(".
    */

   if (in_trace) REJECT ;

   memcpy( retvalue, yytext, yyleng + 1 ); /* include terminating '\0' */
   mem_upper( retvalue, yyleng );

   if (in_numform)
   {
      parser_data.tline = linenr - 1 ; /* set tline for exiterror */
      exiterror( ERR_INV_SUBKEYWORD, 11, "ENGINEERING SCIENTIFIC", retvalue ) ;
   }

   if ( ( last_in_address == in_address_keyword )
     && ( in_address == in_address_main ) )
   {
      kill_next_space = 1 ;
      in_call = 0 ;
      SET_NEXTSTART() ;
      return SIMSYMBOL ;
   }

   BEGIN other;

   if ( in_call )
   {
      /*
       * This has precedence over checking the parenthesis below.
       * Fixes bug 521502.
       */
      in_call = 0;
      kill_next_space = 1;
      SET_NEXTSTART();
      return SIMSYMBOL;
   }

   if ( in_parse == 2 )
   {
      /*
       * This has precedence over checking the parenthesis below.
       * Fixes bug 1109335.
       */
      in_parse = 1;
      kill_next_space = 1;
      SET_NEXTSTART();
      return SIMSYMBOL;
   }

   /* We must check if a '(' follows. Remember the number of eaten chars. */
      j = 1;
#ifdef __cplusplus
   for (; ( i = yyinput() ) == '`';)
#else
   for (; ( i = input() ) == '`';)
#endif
     j++ ;
   if (i != '(')
   {
      j-- ;
      unput(i) ;
   }
   /* input() has destroyed the yytext-terminator re-set it */
   yytext[yyleng] = '\0';
   SET_NEXTSTART() ;
   nextstart += j ;

   if ( i == '(' )
   {
      kill_next_space = 1 ;
      if ( insert_abuttal )
      {
         inhibit_delayed_abuttal = 1 ;
         delayed_symbol = INFUNCNAME ;
         return CONCATENATE ;
      }
      expression_ended = 0 ;
      return INFUNCNAME ;
   }

   if ( insert_abuttal && !in_parse ) {
      delayed_symbol = SIMSYMBOL ;
      return CONCATENATE ; }

   expression_ended = 1 ;

   if ( in_address == in_address_with )
      kill_next_space = 1 ;
   if (SymbolDetect) /* allow a fast breakout */
   {
      /* We define a tricky preprocessor directive. This will give us
       * maximum performance without the loss of control or errors produced
       * by typos.
       */
#define RET_IF(s)  if ((SymbolDetect & SD_##s) &&      \
                       (yyleng == sizeof(#s) - 1) &&   \
                       (strncmp(retvalue,              \
                                #s,                    \
                                sizeof(#s) - 1) == 0)) \
                      return(s)
      /* e.g. RET_IF(INPUT); is replaced by:
       *  if ((SymbolDetect & SD_INPUT) &&
       *      (yyleng == sizeof("INPUT") - 1) &&
       *      (strncmp(retvalue,
       *               "INPUT",
       *               sizeof("INPUT") - 1) == 0))
       *     return(s);
       */
      RET_IF(INPUT);
      RET_IF(OUTPUT);
      RET_IF(ERROR);
      RET_IF(NORMAL);
      RET_IF(APPEND);
      RET_IF(REPLACE);
      RET_IF(STREAM);
      RET_IF(STEM);
      RET_IF(LIFO);
      RET_IF(FIFO);
#undef RET_IF
   }
   return SIMSYMBOL ; }
	YY_BREAK
case 111:
YY_RULE_SETUP
#line 1679 "./lexsrc.l"
{
   int i,j;
   /*
    * this is mainly the content of var_symbol but we do a REJECT for all but
    * normal variable names.
    */

   if ( in_trace || in_numform || in_call )
      REJECT;

   if ( ( last_in_address == in_address_keyword )
     && ( in_address == in_address_main ) )
      REJECT;

   set_assignment( '=' );
   if ( !KNOWN_RESERVED( retvalue, retlength ) )
      REJECT;

   /* We must check if a '(' follows. Remember the number of eaten chars. */
#ifdef __cplusplus
   for ( j = 1; ( i = yyinput() ) == '`'; )
#else
   for ( j = 1; ( i = input() ) == '`'; )
#endif
     j++;
   if ( i != '(' )
   {
      j--;
      unput( i );
   }
   /* input() has destroyed the yytext-terminator re-set it */
   yytext[yyleng] = '\0';
   SET_NEXTSTART();
   nextstart += j;

   if ( i == '(' )
      REJECT; /* function name can't start with '.' */

   BEGIN other;
   if ( insert_abuttal && !in_parse )
   {
      delayed_symbol = SIMSYMBOL;
      return CONCATENATE;
   }

   expression_ended = 1;
   return SIMSYMBOL;
   }
	YY_BREAK
case 112:
YY_RULE_SETUP
#line 1728 "./lexsrc.l"
{
   expression_ended = 1 ;
   SET_NEXTSTART() ;
   return ')' ; }
	YY_BREAK
case 113:
YY_RULE_SETUP
#line 1733 "./lexsrc.l"
{
   BEGIN other ;
   if ( insert_abuttal )
   {
      inhibit_delayed_abuttal = 1 ;
      delayed_symbol = '(' ;
      SET_NEXTSTART() ;
      return CONCATENATE ;
   }
   SET_NEXTSTART() ;
   return '(' ; }
	YY_BREAK
case 114:
YY_RULE_SETUP
#line 1745 "./lexsrc.l"
{
   SET_NEXTSTART() ;
   return ',' ; }
	YY_BREAK
case 115:
YY_RULE_SETUP
#line 1749 "./lexsrc.l"
{
   BEGIN other ;
   SET_NEXTSTART() ;
   return '-' ; }
	YY_BREAK
case 116:
YY_RULE_SETUP
#line 1754 "./lexsrc.l"
{
   BEGIN other ;
   SET_NEXTSTART() ;
   return '+' ; }
	YY_BREAK
case 117:
YY_RULE_SETUP
#line 1759 "./lexsrc.l"
{
   SET_NEXTSTART() ;
   return '/' ; }
	YY_BREAK
case 118:
YY_RULE_SETUP
#line 1763 "./lexsrc.l"
{
   SET_NEXTSTART() ;
   return '%' ; }
	YY_BREAK
case 119:
YY_RULE_SETUP
#line 1767 "./lexsrc.l"
{
   SET_NEXTSTART() ;
   return '*' ; }
	YY_BREAK
case 120:
YY_RULE_SETUP
#line 1771 "./lexsrc.l"
{
   SET_NEXTSTART() ;
   return '|' ; }
	YY_BREAK
case 121:
YY_RULE_SETUP
#line 1775 "./lexsrc.l"
{
   SET_NEXTSTART() ;
   return '&' ; }
	YY_BREAK
case 122:
YY_RULE_SETUP
#line 1779 "./lexsrc.l"
{
   SET_NEXTSTART() ;
   return '=' ; }
	YY_BREAK
case 123:
YY_RULE_SETUP
#line 1783 "./lexsrc.l"
{
   /* why don't I have a {between} in the beginning of this re? bug? */
   BEGIN other ;
   SET_NEXTSTART() ;
   return NOT ; }
	YY_BREAK
case 124:
YY_RULE_SETUP
#line 1789 "./lexsrc.l"
{
   SET_NEXTSTART() ;
   return GTGT ; }
	YY_BREAK
case 125:
YY_RULE_SETUP
#line 1793 "./lexsrc.l"
{
   SET_NEXTSTART() ;
   return LTLT ; }
	YY_BREAK
case 126:
YY_RULE_SETUP
#line 1797 "./lexsrc.l"
{
   SET_NEXTSTART() ;
   return NOTGTGT ; }
	YY_BREAK
case 127:
YY_RULE_SETUP
#line 1801 "./lexsrc.l"
{
   SET_NEXTSTART() ;
   return NOTLTLT ; }
	YY_BREAK
case 128:
YY_RULE_SETUP
#line 1805 "./lexsrc.l"
{
   SET_NEXTSTART() ;
   return GTGTE ; }
	YY_BREAK
case 129:
YY_RULE_SETUP
#line 1809 "./lexsrc.l"
{
   SET_NEXTSTART() ;
   return LTLTE ; }
	YY_BREAK
case 130:
YY_RULE_SETUP
#line 1813 "./lexsrc.l"
{
   SET_NEXTSTART() ;
   return GT ; }
	YY_BREAK
case 131:
YY_RULE_SETUP
#line 1817 "./lexsrc.l"
{
   SET_NEXTSTART() ;
   return GTE ; }
	YY_BREAK
case 132:
YY_RULE_SETUP
#line 1821 "./lexsrc.l"
{
   SET_NEXTSTART() ;
   return LT ; }
	YY_BREAK
case 133:
YY_RULE_SETUP
#line 1825 "./lexsrc.l"
{
   SET_NEXTSTART() ;
   return LTE ; }
	YY_BREAK
case 134:
YY_RULE_SETUP
#line 1829 "./lexsrc.l"
{
   SET_NEXTSTART() ;
   return DIFFERENT ; }
	YY_BREAK
case 135:
YY_RULE_SETUP
#line 1833 "./lexsrc.l"
{
   SET_NEXTSTART() ;
   return EQUALEQUAL ; }
	YY_BREAK
case 136:
YY_RULE_SETUP
#line 1837 "./lexsrc.l"
{
   SET_NEXTSTART() ;
   return NOTEQUALEQUAL ; }
	YY_BREAK
case 137:
YY_RULE_SETUP
#line 1841 "./lexsrc.l"
{
   SET_NEXTSTART() ;
   return MODULUS ; }
	YY_BREAK
case 138:
YY_RULE_SETUP
#line 1845 "./lexsrc.l"
{
   SET_NEXTSTART() ;
   return XOR ; }
	YY_BREAK
case 139:
YY_RULE_SETUP
#line 1849 "./lexsrc.l"
{
   SET_NEXTSTART() ;
   return CONCATENATE ; }
	YY_BREAK
case 140:
YY_RULE_SETUP
#line 1853 "./lexsrc.l"
{
   SET_NEXTSTART() ;
   return EXP ; }
	YY_BREAK
case 141:
YY_RULE_SETUP
#line 1857 "./lexsrc.l"
{
   if ( in_address == in_address_value ) /* Always allow spaces in the VALUE */
   {                                   /* part of the ADDRESS stmt.        */
      SET_NEXTSTART() ;
      return SPACE ;
   }
   if (kill_this_space)
   {
      SET_NEXTSTART() ;
      return yylex() ;
   }
   SET_NEXTSTART() ;
   return (((in_parse)&&(!seek_with)) ? yylex() : SPACE) ; }
	YY_BREAK
case 142:
YY_RULE_SETUP
#line 1871 "./lexsrc.l"
{
   SET_NEXTSTART() ;
   parser_data.tline = linenr - 1 ; /* set tline for exiterror */
   exiterror( ERR_UNMATCHED_QUOTE, 0 )  ; }
	YY_BREAK
case 143:
YY_RULE_SETUP
#line 1877 "./lexsrc.l"
{
   SET_NEXTSTART() ;
   parser_data.tline = linenr - 1 ; /* set tline for exiterror */
   exiterror( ERR_SYMBOL_EXPECTED, 1, yytext ) ;}
	YY_BREAK
case 144:
YY_RULE_SETUP
#line 1882 "./lexsrc.l"
{
   SET_NEXTSTART() ;
   parser_data.tline = linenr - 1 ; /* set tline for exiterror */
   exiterror( ERR_INVALID_CHAR, 1, yytext[0], yytext[0] ); }
	YY_BREAK
case 145:
YY_RULE_SETUP
#line 1888 "./lexsrc.l"
ECHO;
	YY_BREAK
#line 4875 "./lexsrc.c"
			case YY_STATE_EOF(INITIAL):
			case YY_STATE_EOF(comm):
			case YY_STATE_EOF(signal):
			case YY_STATE_EOF(sgtype):
			case YY_STATE_EOF(procd):
			case YY_STATE_EOF(parse):
			case YY_STATE_EOF(then):
			case YY_STATE_EOF(with):
			case YY_STATE_EOF(numeric):
			case YY_STATE_EOF(do1):
			case YY_STATE_EOF(other):
			case YY_STATE_EOF(value1):
			case YY_STATE_EOF(ifcont):
			case YY_STATE_EOF(signame):
			case YY_STATE_EOF(nmform):
				yyterminate();

	case YY_END_OF_BUFFER:
		{
		/* Amount of text matched not including the EOB char. */
		int yy_amount_of_matched_text = (int) (yy_cp - (yytext_ptr)) - 1;

		/* Undo the effects of YY_DO_BEFORE_ACTION. */
		*yy_cp = (yy_hold_char);
		YY_RESTORE_YY_MORE_OFFSET

		if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_NEW )
			{
			/* We're scanning a new file or input source.  It's
			 * possible that this happened because the user
			 * just pointed yyin at a new source and called
			 * yylex().  If so, then we have to assure
			 * consistency between YY_CURRENT_BUFFER and our
			 * globals.  Here is the right place to do so, because
			 * this is the first action (other than possibly a
			 * back-up) that will match for the new input source.
			 */
			(yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;
			YY_CURRENT_BUFFER_LVALUE->yy_input_file = yyin;
			YY_CURRENT_BUFFER_LVALUE->yy_buffer_status = YY_BUFFER_NORMAL;
			}

		/* Note that here we test for yy_c_buf_p "<=" to the position
		 * of the first EOB in the buffer, since yy_c_buf_p will
		 * already have been incremented past the NUL character
		 * (since all states make transitions on EOB to the
		 * end-of-buffer state).  Contrast this with the test
		 * in input().
		 */
		if ( (yy_c_buf_p) <= &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] )
			{ /* This was really a NUL. */
			yy_state_type yy_next_state;

			(yy_c_buf_p) = (yytext_ptr) + yy_amount_of_matched_text;

			yy_current_state = yy_get_previous_state(  );

			/* Okay, we're now positioned to make the NUL
			 * transition.  We couldn't have
			 * yy_get_previous_state() go ahead and do it
			 * for us because it doesn't know how to deal
			 * with the possibility of jamming (and we don't
			 * want to build jamming into it because then it
			 * will run more slowly).
			 */

			yy_next_state = yy_try_NUL_trans( yy_current_state );

			yy_bp = (yytext_ptr) + YY_MORE_ADJ;

			if ( yy_next_state )
				{
				/* Consume the NUL. */
				yy_cp = ++(yy_c_buf_p);
				yy_current_state = yy_next_state;
				goto yy_match;
				}

			else
				{
				yy_cp = (yy_c_buf_p);
				goto yy_find_action;
				}
			}

		else switch ( yy_get_next_buffer(  ) )
			{
			case EOB_ACT_END_OF_FILE:
				{
				(yy_did_buffer_switch_on_eof) = 0;

				if ( yywrap(  ) )
					{
					/* Note: because we've taken care in
					 * yy_get_next_buffer() to have set up
					 * yytext, we can now set up
					 * yy_c_buf_p so that if some total
					 * hoser (like flex itself) wants to
					 * call the scanner after we return the
					 * YY_NULL, it'll still work - another
					 * YY_NULL will get returned.
					 */
					(yy_c_buf_p) = (yytext_ptr) + YY_MORE_ADJ;

					yy_act = YY_STATE_EOF(YY_START);
					goto do_action;
					}

				else
					{
					if ( ! (yy_did_buffer_switch_on_eof) )
						YY_NEW_FILE;
					}
				break;
				}

			case EOB_ACT_CONTINUE_SCAN:
				(yy_c_buf_p) =
					(yytext_ptr) + yy_amount_of_matched_text;

				yy_current_state = yy_get_previous_state(  );

				yy_cp = (yy_c_buf_p);
				yy_bp = (yytext_ptr) + YY_MORE_ADJ;
				goto yy_match;

			case EOB_ACT_LAST_MATCH:
				(yy_c_buf_p) =
				&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)];

				yy_current_state = yy_get_previous_state(  );

				yy_cp = (yy_c_buf_p);
				yy_bp = (yytext_ptr) + YY_MORE_ADJ;
				goto yy_find_action;
			}
		break;
		}

	default:
		YY_FATAL_ERROR(
			"fatal flex scanner internal error--no action found" );
	} /* end of action switch */
		} /* end of scanning one token */
	} /* end of user's declarations */
} /* end of yylex */

/* yy_get_next_buffer - try to read in a new buffer
 *
 * Returns a code representing an action:
 *	EOB_ACT_LAST_MATCH -
 *	EOB_ACT_CONTINUE_SCAN - continue scanning from current position
 *	EOB_ACT_END_OF_FILE - end of file
 */
static int yy_get_next_buffer (void)
{
    	char *dest = YY_CURRENT_BUFFER_LVALUE->yy_ch_buf;
	char *source = (yytext_ptr);
	yy_size_t number_to_move, i;
	int ret_val;

	if ( (yy_c_buf_p) > &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars) + 1] )
		YY_FATAL_ERROR(
		"fatal flex scanner internal error--end of buffer missed" );

	if ( YY_CURRENT_BUFFER_LVALUE->yy_fill_buffer == 0 )
		{ /* Don't try to fill the buffer, so this is an EOF. */
		if ( (yy_c_buf_p) - (yytext_ptr) - YY_MORE_ADJ == 1 )
			{
			/* We matched a single character, the EOB, so
			 * treat this as a final EOF.
			 */
			return EOB_ACT_END_OF_FILE;
			}

		else
			{
			/* We matched some text prior to the EOB, first
			 * process it.
			 */
			return EOB_ACT_LAST_MATCH;
			}
		}

	/* Try to read more data. */

	/* First move last chars to start of buffer. */
	number_to_move = (yy_size_t) ((yy_c_buf_p) - (yytext_ptr)) - 1;

	for ( i = 0; i < number_to_move; ++i )
		*(dest++) = *(source++);

	if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_EOF_PENDING )
		/* don't do the read, it's not guaranteed to return an EOF,
		 * just force an EOF
		 */
		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars) = 0;

	else
		{
			yy_size_t num_to_read =
			YY_CURRENT_BUFFER_LVALUE->yy_buf_size - number_to_move - 1;

		while ( num_to_read <= 0 )
			{ /* Not enough room in the buffer - grow it. */

			YY_FATAL_ERROR(
"input buffer overflow, can't enlarge buffer because scanner uses REJECT" );

			}

		if ( num_to_read > YY_READ_BUF_SIZE )
			num_to_read = YY_READ_BUF_SIZE;

		/* Read in more data. */
		YY_INPUT( (&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move]),
			(yy_n_chars), num_to_read );

		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
		}

	if ( (yy_n_chars) == 0 )
		{
		if ( number_to_move == YY_MORE_ADJ )
			{
			ret_val = EOB_ACT_END_OF_FILE;
			yyrestart( yyin  );
			}

		else
			{
			ret_val = EOB_ACT_LAST_MATCH;
			YY_CURRENT_BUFFER_LVALUE->yy_buffer_status =
				YY_BUFFER_EOF_PENDING;
			}
		}

	else
		ret_val = EOB_ACT_CONTINUE_SCAN;

	if ((yy_size_t) ((yy_n_chars) + number_to_move) > YY_CURRENT_BUFFER_LVALUE->yy_buf_size) {
		/* Extend the array by 50%, plus the number we really need. */
		yy_size_t new_size = (yy_n_chars) + number_to_move + ((yy_n_chars) >> 1);
		YY_CURRENT_BUFFER_LVALUE->yy_ch_buf = (char *) yyrealloc(
			(void *) YY_CURRENT_BUFFER_LVALUE->yy_ch_buf, new_size  );
		if ( ! YY_CURRENT_BUFFER_LVALUE->yy_ch_buf )
			YY_FATAL_ERROR( "out of dynamic memory in yy_get_next_buffer()" );
	}

	(yy_n_chars) += number_to_move;
	YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] = YY_END_OF_BUFFER_CHAR;
	YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars) + 1] = YY_END_OF_BUFFER_CHAR;

	(yytext_ptr) = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[0];

	return ret_val;
}

/* yy_get_previous_state - get the state just before the EOB char was reached */

    static yy_state_type yy_get_previous_state (void)
{
	yy_state_type yy_current_state;
	char *yy_cp;
    
	yy_current_state = (yy_start);

	(yy_state_ptr) = (yy_state_buf);
	*(yy_state_ptr)++ = yy_current_state;

	for ( yy_cp = (yytext_ptr) + YY_MORE_ADJ; yy_cp < (yy_c_buf_p); ++yy_cp )
		{
		YY_CHAR yy_c = (*yy_cp ? yy_ec[YY_SC_TO_UI(*yy_cp)] : 1);
		while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
			{
			yy_current_state = (int) yy_def[yy_current_state];
			if ( yy_current_state >= 1001 )
				yy_c = yy_meta[(unsigned int) yy_c];
			}
		yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
		*(yy_state_ptr)++ = yy_current_state;
		}

	return yy_current_state;
}

/* yy_try_NUL_trans - try to make a transition on the NUL character
 *
 * synopsis
 *	next_state = yy_try_NUL_trans( current_state );
 */
    static yy_state_type yy_try_NUL_trans  (yy_state_type yy_current_state )
{
	int yy_is_jam;
    
	YY_CHAR yy_c = 1;
	while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
		{
		yy_current_state = (int) yy_def[yy_current_state];
		if ( yy_current_state >= 1001 )
			yy_c = yy_meta[(unsigned int) yy_c];
		}
	yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
	yy_is_jam = (yy_current_state == 1000);
	if ( ! yy_is_jam )
		*(yy_state_ptr)++ = yy_current_state;

		return yy_is_jam ? 0 : yy_current_state;
}

#ifndef YY_NO_UNPUT

    static void yyunput (int c, char * yy_bp )
{
	char *yy_cp;
    
    yy_cp = (yy_c_buf_p);

	/* undo effects of setting up yytext */
	*yy_cp = (yy_hold_char);

	if ( yy_cp < YY_CURRENT_BUFFER_LVALUE->yy_ch_buf + 2 )
		{ /* need to shift things up to make room */
		/* +2 for EOB chars. */
		yy_size_t number_to_move = (yy_n_chars) + 2;
		char *dest = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[
					YY_CURRENT_BUFFER_LVALUE->yy_buf_size + 2];
		char *source =
				&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move];

		while ( source > YY_CURRENT_BUFFER_LVALUE->yy_ch_buf )
			*--dest = *--source;

		yy_cp += (int) (dest - source);
		yy_bp += (int) (dest - source);
		YY_CURRENT_BUFFER_LVALUE->yy_n_chars =
			(yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_buf_size;

		if ( yy_cp < YY_CURRENT_BUFFER_LVALUE->yy_ch_buf + 2 )
			YY_FATAL_ERROR( "flex scanner push-back overflow" );
		}

	*--yy_cp = (char) c;

	(yytext_ptr) = yy_bp;
	(yy_hold_char) = *yy_cp;
	(yy_c_buf_p) = yy_cp;
}

#endif

#ifndef YY_NO_INPUT
#ifdef __cplusplus
    static int yyinput (void)
#else
    static int input  (void)
#endif

{
	int c;
    
	*(yy_c_buf_p) = (yy_hold_char);

	if ( *(yy_c_buf_p) == YY_END_OF_BUFFER_CHAR )
		{
		/* yy_c_buf_p now points to the character we want to return.
		 * If this occurs *before* the EOB characters, then it's a
		 * valid NUL; if not, then we've hit the end of the buffer.
		 */
		if ( (yy_c_buf_p) < &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] )
			/* This was really a NUL. */
			*(yy_c_buf_p) = '\0';

		else
			{ /* need more input */
			yy_size_t offset = (yy_c_buf_p) - (yytext_ptr);
			++(yy_c_buf_p);

			switch ( yy_get_next_buffer(  ) )
				{
				case EOB_ACT_LAST_MATCH:
					/* This happens because yy_g_n_b()
					 * sees that we've accumulated a
					 * token and flags that we need to
					 * try matching the token before
					 * proceeding.  But for input(),
					 * there's no matching to consider.
					 * So convert the EOB_ACT_LAST_MATCH
					 * to EOB_ACT_END_OF_FILE.
					 */

					/* Reset buffer status. */
					yyrestart( yyin );

					/*FALLTHROUGH*/

				case EOB_ACT_END_OF_FILE:
					{
					if ( yywrap(  ) )
						return EOF;

					if ( ! (yy_did_buffer_switch_on_eof) )
						YY_NEW_FILE;
#ifdef __cplusplus
					return yyinput();
#else
					return input();
#endif
					}

				case EOB_ACT_CONTINUE_SCAN:
					(yy_c_buf_p) = (yytext_ptr) + offset;
					break;
				}
			}
		}

	c = *(unsigned char *) (yy_c_buf_p);	/* cast for 8-bit char's */
	*(yy_c_buf_p) = '\0';	/* preserve yytext */
	(yy_hold_char) = *++(yy_c_buf_p);

	return c;
}
#endif	/* ifndef YY_NO_INPUT */

/** Immediately switch to a different input stream.
 * @param input_file A readable stream.
 * 
 * @note This function does not reset the start condition to @c INITIAL .
 */
    void yyrestart  (FILE * input_file )
{
    
	if ( ! YY_CURRENT_BUFFER ){
        yyensure_buffer_stack ();
		YY_CURRENT_BUFFER_LVALUE =
            yy_create_buffer( yyin, YY_BUF_SIZE );
	}

	yy_init_buffer( YY_CURRENT_BUFFER, input_file );
	yy_load_buffer_state(  );
}

/** Switch to a different input buffer.
 * @param new_buffer The new input buffer.
 * 
 */
    void yy_switch_to_buffer  (YY_BUFFER_STATE  new_buffer )
{
    
	/* TODO. We should be able to replace this entire function body
	 * with
	 *		yypop_buffer_state();
	 *		yypush_buffer_state(new_buffer);
     */
	yyensure_buffer_stack ();
	if ( YY_CURRENT_BUFFER == new_buffer )
		return;

	if ( YY_CURRENT_BUFFER )
		{
		/* Flush out information for old buffer. */
		*(yy_c_buf_p) = (yy_hold_char);
		YY_CURRENT_BUFFER_LVALUE->yy_buf_pos = (yy_c_buf_p);
		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
		}

	YY_CURRENT_BUFFER_LVALUE = new_buffer;
	yy_load_buffer_state(  );

	/* We don't actually know whether we did this switch during
	 * EOF (yywrap()) processing, but the only time this flag
	 * is looked at is after yywrap() is called, so it's safe
	 * to go ahead and always set it.
	 */
	(yy_did_buffer_switch_on_eof) = 1;
}

static void yy_load_buffer_state  (void)
{
    	(yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;
	(yytext_ptr) = (yy_c_buf_p) = YY_CURRENT_BUFFER_LVALUE->yy_buf_pos;
	yyin = YY_CURRENT_BUFFER_LVALUE->yy_input_file;
	(yy_hold_char) = *(yy_c_buf_p);
}

/** Allocate and initialize an input buffer state.
 * @param file A readable stream.
 * @param size The character buffer size in bytes. When in doubt, use @c YY_BUF_SIZE.
 * 
 * @return the allocated buffer state.
 */
    YY_BUFFER_STATE yy_create_buffer  (FILE * file, int  size )
{
	YY_BUFFER_STATE b;
    
	b = (YY_BUFFER_STATE) yyalloc( sizeof( struct yy_buffer_state )  );
	if ( ! b )
		YY_FATAL_ERROR( "out of dynamic memory in yy_create_buffer()" );

	b->yy_buf_size = (yy_size_t)size;

	/* yy_ch_buf has to be 2 characters longer than the size given because
	 * we need to put in 2 end-of-buffer characters.
	 */
	b->yy_ch_buf = (char *) yyalloc( b->yy_buf_size + 2  );
	if ( ! b->yy_ch_buf )
		YY_FATAL_ERROR( "out of dynamic memory in yy_create_buffer()" );

	b->yy_is_our_buffer = 1;

	yy_init_buffer( b, file );

	return b;
}

/** Destroy the buffer.
 * @param b a buffer created with yy_create_buffer()
 * 
 */
    void yy_delete_buffer (YY_BUFFER_STATE  b )
{
    
	if ( ! b )
		return;

	if ( b == YY_CURRENT_BUFFER ) /* Not sure if we should pop here. */
		YY_CURRENT_BUFFER_LVALUE = (YY_BUFFER_STATE) 0;

	if ( b->yy_is_our_buffer )
		yyfree( (void *) b->yy_ch_buf  );

	yyfree( (void *) b  );
}

/* Initializes or reinitializes a buffer.
 * This function is sometimes called more than once on the same buffer,
 * such as during a yyrestart() or at EOF.
 */
    static void yy_init_buffer  (YY_BUFFER_STATE  b, FILE * file )

{
	int oerrno = errno;
    
	yy_flush_buffer( b );

	b->yy_input_file = file;
	b->yy_fill_buffer = 1;

    /* If b is the current buffer, then yy_init_buffer was _probably_
     * called from yyrestart() or through yy_get_next_buffer.
     * In that case, we don't want to reset the lineno or column.
     */
    if (b != YY_CURRENT_BUFFER){
        b->yy_bs_lineno = 1;
        b->yy_bs_column = 0;
    }

        b->yy_is_interactive = file ? (isatty( fileno(file) ) > 0) : 0;
    
	errno = oerrno;
}

/** Discard all buffered characters. On the next scan, YY_INPUT will be called.
 * @param b the buffer state to be flushed, usually @c YY_CURRENT_BUFFER.
 * 
 */
    void yy_flush_buffer (YY_BUFFER_STATE  b )
{
    	if ( ! b )
		return;

	b->yy_n_chars = 0;

	/* We always need two end-of-buffer characters.  The first causes
	 * a transition to the end-of-buffer state.  The second causes
	 * a jam in that state.
	 */
	b->yy_ch_buf[0] = YY_END_OF_BUFFER_CHAR;
	b->yy_ch_buf[1] = YY_END_OF_BUFFER_CHAR;

	b->yy_buf_pos = &b->yy_ch_buf[0];

	b->yy_at_bol = 1;
	b->yy_buffer_status = YY_BUFFER_NEW;

	if ( b == YY_CURRENT_BUFFER )
		yy_load_buffer_state(  );
}

/** Pushes the new state onto the stack. The new state becomes
 *  the current state. This function will allocate the stack
 *  if necessary.
 *  @param new_buffer The new state.
 *  
 */
void yypush_buffer_state (YY_BUFFER_STATE new_buffer )
{
    	if (new_buffer == NULL)
		return;

	yyensure_buffer_stack();

	/* This block is copied from yy_switch_to_buffer. */
	if ( YY_CURRENT_BUFFER )
		{
		/* Flush out information for old buffer. */
		*(yy_c_buf_p) = (yy_hold_char);
		YY_CURRENT_BUFFER_LVALUE->yy_buf_pos = (yy_c_buf_p);
		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
		}

	/* Only push if top exists. Otherwise, replace top. */
	if (YY_CURRENT_BUFFER)
		(yy_buffer_stack_top)++;
	YY_CURRENT_BUFFER_LVALUE = new_buffer;

	/* copied from yy_switch_to_buffer. */
	yy_load_buffer_state(  );
	(yy_did_buffer_switch_on_eof) = 1;
}

/** Removes and deletes the top of the stack, if present.
 *  The next element becomes the new top.
 *  
 */
void yypop_buffer_state (void)
{
    	if (!YY_CURRENT_BUFFER)
		return;

	yy_delete_buffer(YY_CURRENT_BUFFER );
	YY_CURRENT_BUFFER_LVALUE = NULL;
	if ((yy_buffer_stack_top) > 0)
		--(yy_buffer_stack_top);

	if (YY_CURRENT_BUFFER) {
		yy_load_buffer_state(  );
		(yy_did_buffer_switch_on_eof) = 1;
	}
}

/* Allocates the stack if it does not exist.
 *  Guarantees space for at least one push.
 */
static void yyensure_buffer_stack (void)
{
	yy_size_t num_to_alloc;
    
	if (!(yy_buffer_stack)) {

		/* First allocation is just for 2 elements, since we don't know if this
		 * scanner will even need a stack. We use 2 instead of 1 to avoid an
		 * immediate realloc on the next call.
         */
		num_to_alloc = 1; // After all that talk, this was set to 1 anyways...
		(yy_buffer_stack) = (struct yy_buffer_state**)yyalloc
								(num_to_alloc * sizeof(struct yy_buffer_state*)
								);
		if ( ! (yy_buffer_stack) )
			YY_FATAL_ERROR( "out of dynamic memory in yyensure_buffer_stack()" );
								  
		memset((yy_buffer_stack), 0, num_to_alloc * sizeof(struct yy_buffer_state*));
				
		(yy_buffer_stack_max) = num_to_alloc;
		(yy_buffer_stack_top) = 0;
		return;
	}

	if ((yy_buffer_stack_top) >= ((yy_buffer_stack_max)) - 1){

		/* Increase the buffer to prepare for a possible push. */
		yy_size_t grow_size = 8 /* arbitrary grow size */;

		num_to_alloc = (yy_buffer_stack_max) + grow_size;
		(yy_buffer_stack) = (struct yy_buffer_state**)yyrealloc
								((yy_buffer_stack),
								num_to_alloc * sizeof(struct yy_buffer_state*)
								);
		if ( ! (yy_buffer_stack) )
			YY_FATAL_ERROR( "out of dynamic memory in yyensure_buffer_stack()" );

		/* zero only the new slots.*/
		memset((yy_buffer_stack) + (yy_buffer_stack_max), 0, grow_size * sizeof(struct yy_buffer_state*));
		(yy_buffer_stack_max) = num_to_alloc;
	}
}

/** Setup the input buffer state to scan directly from a user-specified character buffer.
 * @param base the character buffer
 * @param size the size in bytes of the character buffer
 * 
 * @return the newly allocated buffer state object. 
 */
YY_BUFFER_STATE yy_scan_buffer  (char * base, yy_size_t  size )
{
	YY_BUFFER_STATE b;
    
	if ( size < 2 ||
	     base[size-2] != YY_END_OF_BUFFER_CHAR ||
	     base[size-1] != YY_END_OF_BUFFER_CHAR )
		/* They forgot to leave room for the EOB's. */
		return 0;

	b = (YY_BUFFER_STATE) yyalloc( sizeof( struct yy_buffer_state )  );
	if ( ! b )
		YY_FATAL_ERROR( "out of dynamic memory in yy_scan_buffer()" );

	b->yy_buf_size = size - 2;	/* "- 2" to take care of EOB's */
	b->yy_buf_pos = b->yy_ch_buf = base;
	b->yy_is_our_buffer = 0;
	b->yy_input_file = 0;
	b->yy_n_chars = b->yy_buf_size;
	b->yy_is_interactive = 0;
	b->yy_at_bol = 1;
	b->yy_fill_buffer = 0;
	b->yy_buffer_status = YY_BUFFER_NEW;

	yy_switch_to_buffer( b  );

	return b;
}

/** Setup the input buffer state to scan a string. The next call to yylex() will
 * scan from a @e copy of @a str.
 * @param yystr a NUL-terminated string to scan
 * 
 * @return the newly allocated buffer state object.
 * @note If you want to scan bytes that may contain NUL values, then use
 *       yy_scan_bytes() instead.
 */
YY_BUFFER_STATE yy_scan_string (yyconst char * yystr )
{
    
	return yy_scan_bytes( yystr, strlen(yystr) );
}

/** Setup the input buffer state to scan the given bytes. The next call to yylex() will
 * scan from a @e copy of @a bytes.
 * @param yybytes the byte buffer to scan
 * @param _yybytes_len the number of bytes in the buffer pointed to by @a bytes.
 * 
 * @return the newly allocated buffer state object.
 */
YY_BUFFER_STATE yy_scan_bytes  (yyconst char * yybytes, yy_size_t  _yybytes_len )
{
	YY_BUFFER_STATE b;
	char *buf;
	yy_size_t n;
	yy_size_t i;
    
	/* Get memory for full buffer, including space for trailing EOB's. */
	n = _yybytes_len + 2;
	buf = (char *) yyalloc( n  );
	if ( ! buf )
		YY_FATAL_ERROR( "out of dynamic memory in yy_scan_bytes()" );

	for ( i = 0; i < _yybytes_len; ++i )
		buf[i] = yybytes[i];

	buf[_yybytes_len] = buf[_yybytes_len+1] = YY_END_OF_BUFFER_CHAR;

	b = yy_scan_buffer( buf, n );
	if ( ! b )
		YY_FATAL_ERROR( "bad buffer in yy_scan_bytes()" );

	/* It's okay to grow etc. this buffer, and we should throw it
	 * away when we're done.
	 */
	b->yy_is_our_buffer = 1;

	return b;
}

#ifndef YY_EXIT_FAILURE
#define YY_EXIT_FAILURE 2
#endif

static void yy_fatal_error (yyconst char* msg )
{
			(void) fprintf( stderr, "%s\n", msg );
	exit( YY_EXIT_FAILURE );
}

/* Redefine yyless() so it works in section 3 code. */

#undef yyless
#define yyless(n) \
	do \
		{ \
		/* Undo effects of setting up yytext. */ \
        int yyless_macro_arg = (n); \
        YY_LESS_LINENO(yyless_macro_arg);\
		yytext[yyleng] = (yy_hold_char); \
		(yy_c_buf_p) = yytext + yyless_macro_arg; \
		(yy_hold_char) = *(yy_c_buf_p); \
		*(yy_c_buf_p) = '\0'; \
		yyleng = yyless_macro_arg; \
		} \
	while ( 0 )

/* Accessor  methods (get/set functions) to struct members. */

/** Get the current line number.
 * 
 */
int yyget_lineno  (void)
{
        
    return yylineno;
}

/** Get the input stream.
 * 
 */
FILE *yyget_in  (void)
{
        return yyin;
}

/** Get the output stream.
 * 
 */
FILE *yyget_out  (void)
{
        return yyout;
}

/** Get the length of the current token.
 * 
 */
yy_size_t yyget_leng  (void)
{
        return yyleng;
}

/** Get the current token.
 * 
 */

char *yyget_text  (void)
{
        return yytext;
}

/** Set the current line number.
 * @param _line_number line number
 * 
 */
void yyset_lineno (int  _line_number )
{
    
    yylineno = _line_number;
}

/** Set the input stream. This does not discard the current
 * input buffer.
 * @param _in_str A readable stream.
 * 
 * @see yy_switch_to_buffer
 */
void yyset_in (FILE *  _in_str )
{
        yyin = _in_str ;
}

void yyset_out (FILE *  _out_str )
{
        yyout = _out_str ;
}

int yyget_debug  (void)
{
        return yy_flex_debug;
}

void yyset_debug (int  _bdebug )
{
        yy_flex_debug = _bdebug ;
}

static int yy_init_globals (void)
{
        /* Initialization is the same as for the non-reentrant scanner.
     * This function is called from yylex_destroy(), so don't allocate here.
     */

    (yy_buffer_stack) = 0;
    (yy_buffer_stack_top) = 0;
    (yy_buffer_stack_max) = 0;
    (yy_c_buf_p) = (char *) 0;
    (yy_init) = 0;
    (yy_start) = 0;

    (yy_state_buf) = 0;
    (yy_state_ptr) = 0;
    (yy_full_match) = 0;
    (yy_lp) = 0;

/* Defined in main.c */
#ifdef YY_STDINIT
    yyin = stdin;
    yyout = stdout;
    yyin_io = yyin;
    yyout_io = yyout;
#else
    yyin = (FILE *) 0;
    yyout = (FILE *) 0;
    yyin_io = yyin;
    yyout_io = yyout;
#endif

    /* For future reference: Set errno on error, since we are called by
     * yylex_init()
     */
    return 0;
}

/* yylex_destroy is for both reentrant and non-reentrant scanners. */
int yylex_destroy  (void)
{
    
    /* Pop the buffer stack, destroying each element. */
	while(YY_CURRENT_BUFFER){
		yy_delete_buffer( YY_CURRENT_BUFFER  );
		YY_CURRENT_BUFFER_LVALUE = NULL;
		yypop_buffer_state();
	}

	/* Destroy the stack itself. */
	yyfree((yy_buffer_stack) );
	(yy_buffer_stack) = NULL;

    yyfree ( (yy_state_buf) );
    (yy_state_buf)  = NULL;

    /* Reset the globals. This is important in a non-reentrant scanner so the next time
     * yylex() is called, initialization will occur. */
    yy_init_globals( );

    return 0;
}

/*
 * Internal utility routines.
 */

#ifndef yytext_ptr
static void yy_flex_strncpy (char* s1, yyconst char * s2, int n )
{
		
	int i;
	for ( i = 0; i < n; ++i )
		s1[i] = s2[i];
}
#endif

#ifdef YY_NEED_STRLEN
static int yy_flex_strlen (yyconst char * s )
{
	int n;
	for ( n = 0; s[n]; ++n )
		;

	return n;
}
#endif

void *yyalloc (yy_size_t  size )
{
			return (void *) malloc( size );
}

void *yyrealloc  (void * ptr, yy_size_t  size )
{
		
	/* The cast to (char *) in the following accommodates both
	 * implementations that use char* generic pointers, and those
	 * that use void* generic pointers.  It works with the latter
	 * because both ANSI C and C++ allow castless assignment from
	 * any pointer type to void*, and deal with argument conversions
	 * as though doing an assignment.
	 */
	return (void *) realloc( (char *) ptr, size );
}

void yyfree (void * ptr )
{
			free( (char *) ptr );	/* see yyrealloc() for (char *) cast */
}

#define YYTABLES_NAME "yytables"

#line 1888 "./lexsrc.l"



#define NORMALSTAT  0
#define COMMENTSTAT 1
#define SINGLEQUOTE 2
#define DOUBLEQUOTE 3

/*
 * set_assignment sets an assignment variable in retvalue from yytext with
 * a trailing {between}[={between}] stripped.
 * retlength is set, too.
 */
static void set_assignment( char delim )
{
   char ch;

   for( retlength = 0; ( ch = yytext[retlength] ) != 0; retlength++ )
   {
      /*
       * A blank or delim can't occur in the normal text. They are terminators.
       */
      if ( ( ch == delim )
        || ( ch == '\n' )
        || ( MY_ISBLANK( ch ) ) )
         break;
      retvalue[retlength] = (char) rx_toupper( ch );
   }
   retvalue[retlength] = '\0' ;
}

/* rmspc uppercases all characters and removes blanks from a string.
 * Returns the input string.
 */
static YY_CHAR_TYPE *rmspc( YY_CHAR_TYPE *instr )
{
   YY_CHAR_TYPE *retval=instr ,
                *dest  =instr ,
                c ;

   while ((c = *instr++) != '\0')
   {
      c = (YY_CHAR_TYPE) rx_toupper(c);
      /* These characters are treated as blanks: */
      if ((c!='`') && (c!=' ') && (c!=',') && (c!='\t') && (c!='\n'))
         *dest++ = c ;
   }
   *dest = '\0' ;

   return( retval ) ;
}

/*
 * process_number_or_const does the processing of a decimal number or a const.
 * The detection was to complicated to put it into one routine.
 * We have to read some more characters to decide whether or not we have
 * an INFUNCNAME.
 * Returns a lexical code.
 */
static int process_number_or_const( const char *text, int len )
{
   int eaten,c,symbol;

   /*
    * Copy and uppercase the return value.
    */
   memcpy( retvalue, text, len + 1 ); /* include terminating '\0' */
   mem_upper( retvalue, len );

   if ( in_numform )
   {
      parser_data.tline = linenr - 1; /* set tline for exiterror */
      exiterror( ERR_INV_SUBKEYWORD, 11, "ENGINEERING SCIENTIFIC", retvalue );
   }
   nextstart += len;

   BEGIN other;

   /*
    * Plain number or const_symbol.
    */
   if ( KNOWN_RESERVED( retvalue, len ) )
      symbol = SIMSYMBOL;
   else
      symbol = CONSYMBOL;

   if ( in_call )
   {
      /*
       * This has precedence over checking the parenthesis below.
       * Fixes bug 521502.
       */
      in_call = 0;
      kill_next_space = 1;
      SET_NEXTSTART();
      return symbol;
   }

   /*
    * We must check if a '(' follows. Remember the number of eaten chars.
    */
   eaten = 1;
#ifdef __cplusplus
   while ( ( c = yyinput() ) == '`' )
#else
   while ( ( c = input() ) == '`' )
#endif
   {
     eaten++;
   }
   if ( c != '(' )
   {
      eaten--;
      unput( c );
   }
   /*
    * input() has destroyed the yytext-terminator re-set it
    */
   yytext[yyleng] = '\0';
   nextstart += eaten;
   if ( c == '(' )
   {
      kill_next_space = 1;
      if ( insert_abuttal )
      {
         inhibit_delayed_abuttal = 1;
         delayed_symbol = INFUNCNAME;
         return CONCATENATE;
      }
      expression_ended = 0;
      return INFUNCNAME;
   }

   if ( insert_abuttal && !in_parse )
   {
      delayed_symbol = symbol;
      return CONCATENATE;
   }

   expression_ended = 1;
   return symbol;
}

/*
 * compress_string removes quotes or double quotes from the src and changes
 * double delimiter to one. The delimiter should be either ' or ".
 */
static void compress_string( char *dest, const char *src )
{
   char c, delim = *src++;

   for (;;)
   {
      if ( ( c = *src++ ) == delim )
      {
         if (*src == delim )
         {
            *dest++ = *src++;
         }
         else
         {
            break;
         }
      }
      else
      {
         if ( c == '\n' )
         {
            parser_data.tline = linenr - 1 ; /* set tline for exiterror */
            exiterror( ERR_UNMATCHED_QUOTE, 0 ) ;
         }
         *dest++ = c;
      }
   }
   *dest = '\0';
}

/*
 * process_hex_or_bin_string convert the string in text which is given as
 * a hexstring or a binstring to a "normal" string. base must be either 2 or
 * 16.
 * We rely on having a well-formed string. This must be ensured. It is
 * something of the form "content"x or 'content'b or similar.
 * Returns a lexical code. retvalue and retlength will be filled.
 */
static int process_hex_or_bin_string( char *text, int len, int base )
{
   char c;
   int i,left;
   unsigned char *dest,sum;

   BEGIN other;
   SET_NEXTSTART();

   text++;
   len -= 3;

   /*
    * First, count the number of valid chars to determine the missed leading
    * zeros of the first final character.
    */
   for ( i = 0, left = 0 ; i < len; i++ )
   {
      c = text[i];
      if ( !MY_ISBLANK( c ) )
         left++;
   }

   /*
    * left shall be the count of input char left to process one dest char.
    * Accessing one character after the content's end is allowed.
    */
   left %= ( base == 2 ) ? 8 : 2;

   dest = (unsigned char *) retvalue;
   retlength = 0;

   sum = 0;
   c = *text;
   for (;;)
   {
      while ( len && MY_ISBLANK( c ) )
      {
         c = *++text;
         len--;
      }
      if ( len == 0 )
         break;

      if ( base == 2 )
      {
         if ( left == 0 )
            left = 8;
         sum <<= 1;
         sum |= (unsigned char) ( c - '0' );
      }
      else
      {
         if ( left == 0 )
            left = 2;
         sum <<= 4;
         sum |= HEXVAL( c );
      }
      c = *++text;
      len--;

      if ( --left == 0 )
      {
         dest[retlength++] = sum;
         sum = 0;
      }
   }
   dest[retlength] = '\0';

   /* We must check if a '(' follows. Remember the number of eaten chars. */
   left = 1;
#ifdef __cplusplus
   for (; ( i = yyinput() ) == '`';)
#else
   for (; ( i = input() ) == '`';)
#endif
     left++;
   if (i != '(')
   {
      left--;
      unput(i);
   }
   /* input() has destroyed the yytext-terminator re-set it */
   text[len] = '\0';
   SET_NEXTSTART();
   nextstart += left;

   if (i == '(')
   {
      kill_next_space = 1;
      if (insert_abuttal)
      {
         inhibit_delayed_abuttal = 1;
         delayed_symbol = INFUNCNAME;
         return CONCATENATE;
      }
      expression_ended = 0;
      return INFUNCNAME;
   }

   if ( insert_abuttal && !in_parse && !in_call )
   {
      delayed_symbol = STRING;
      return CONCATENATE;
   }

   if ( in_call )
   {
      in_call = 0;
      kill_next_space = 1;
   }
   else
      expression_ended = 1;

   return ( base == 2 ) ? BINSTRING : HEXSTRING;
}

int get_look_ahead(int c)
{
    //fprintf(stderr, "getla --- %02x", (unsigned char )c);
    //if ( use_ebcdic ) {
        //if ( c != EOF )
            //c = e2a[c];
    //}
    return c;
}

int unget_look_ahead(int c)
{
    //fprintf(stderr, "ungetla --- %02x", (unsigned char )c);
    //if ( use_ebcdic ) {
        //if ( c != EOF )
            //c = a2e[c];
    //}
    return c;
}

extern ReginaIOHandlers io_handlers;

/* get_next_line: Lower level input fetcher.
 * Reads exactly one line from the input stream (file or string).
 * All EOL characters are removed and the result is stored in
 * last_source_line. A check for line overflow occurred here.
 * A special check is done for CP/M ^Z (DOS and friends use this for
 * "backward" compatibility, too).
 * line is filled with valid values on success.
 * max must reflect size of line and should be at least BUFFERSIZE + 2;
 * Returns -1 (no input) or the number of valid chars in line.
 */
static int get_next_line( char *line, int max, FILE *stream )
{
   lineboxptr newline ;
   offsrcline *incore_newline;
   int pos = 0;
   int c = 0;

   if (inEOF) /* You can't use myunputc if EOF is reached! */
      return EOF ;

   while (pos <= max - 2)
   {
      /* get next char */
      if (bufptr>0) {
         int d = chbuffer[--bufptr] ;
         c = get_look_ahead(d) ;
      } else if (ipretflag)
      {
         if (interptr>=interptrmax)
            c = EOF ;
         else
#ifdef ASCII_0_TERMINATES_STRING
            if ((c = *interptr++) == '\0')
               c = EOF ;
#else
            c = *interptr++ ;
#endif
      }
      else
      {
         c = io_handlers.inputGetcHandler(stream, 0, 0);

         if ( parser_data.TSD->HaltRaised )
            halt_raised( parser_data.TSD );
      }

      if ((c=='\r') || (c=='\n') || (c==EOF))
         break ;
      line[pos++] = (char) (unsigned char) c ;
   }

   /* first, check for overflow */
   if ((c!='\r') && (c!='\n') && (c!=EOF))
   {
      parser_data.tline = linenr ; /* set tline for exiterror */
      exiterror( ERR_TOO_LONG_LINE, 0 )  ;
   }

   /* We have either a (first) line terminator or EOF */
   if (c==EOF)
   {
      if ((pos==1) && (line[0]=='\x1A')) /* CP/M ^Z EOF? */
         pos-- ;
      if (pos == 0)
      {
         inEOF = 1 ;
         return EOF ;
      }
      chbuffer[bufptr++] = EOF; /* push back EOF for reuse */
   }
   else
   {
      /* Maybe we have CRLF or LFCR. Check for the pair character. */
      char pairChar = (c == '\r') ? '\n' : '\r';


      /* get one more char and consume it if it is the pair of the EOL */
      if (bufptr > 0)
      {
         if (get_look_ahead(chbuffer[bufptr - 1]) == (int) pairChar)
            bufptr--;
      }
      else if (ipretflag)
      {
         if ((interptr < interptrmax) && (*interptr == pairChar))
            interptr++;
      }
      else
      {
         int next = io_handlers.inputGetcHandler(stream, 0, 0);
         if (next != pairChar)
         {
            /* ungetc may break some runtime stuff. Use the internal lookahead*/
            chbuffer[bufptr++] = unget_look_ahead(next);
         }
         if ( parser_data.TSD->HaltRaised )
            halt_raised( parser_data.TSD );
      }
   }


   cch = 0 ; /* not needed ? */
   line[pos++] = '\n';

   if (parser_data.incore_source)
   {
      /*
       * We can use the incore string to describe a source line, but we
       * MUST incement linenr otherwise .LINE doesn't work in instore macros.
       * This will probably also allow errors to be reported for the correct line number.
       */
      linenr++;
      incore_newline = FreshLine() ;
      incore_newline->length = pos - 1 ;
      incore_newline->offset = last_interptr - parser_data.incore_source ;
      last_interptr = interptr;
      return pos ;
   }

   newline = (lineboxptr)Malloc(sizeof(linebox)) ;
   newline->line = Str_make_TSD( parser_data.TSD, pos - 1 ) ;
   newline->line->len = pos - 1 ;
   memcpy(newline->line->value, line, pos - 1 ) ;
   newline->prev = parser_data.last_source_line ;
   newline->next = NULL ;
   newline->lineno = linenr++ ;

   if (parser_data.first_source_line==NULL)
      parser_data.first_source_line = newline ;
   else
      parser_data.last_source_line->next = newline ;
   parser_data.last_source_line = newline ;

   return pos ;
}

/* fill_buffer: Higher level input fetcher.
 * (To allow the C-file to compile, all Rexx comments in this comment
 *  are written as "{*" "*}" instead of the normal, C-like manner.)
 * Reads lines from the input stream (yyin or string) with get_next_line.
 * Only one line is returned to allow the saving of the line number.
 * This routine replaces all comments by '`' signs. This allows
 * the detection of a "pseudo" blank: The fragment "say x{* *}y" uses two
 * variables, not one called "xy". The parsing of comments must be done
 * here to check for the actual numbers of open and closes ("{*" and "*}").
 * While doing this we must always check for strings since "'{*'" is not part
 * of a comment.
 * Here is a problem: Is this a nested valid comment: "{* '{*' *} *}"?
 * I think so although you cannot remove the outer comment signs without an
 * error. Everything within a comment is a comment (per def.). Counting
 * opens and closes of comment signs is an ugly trick to help the user.
 * He/she must know what he/she is doing if nesting comments!
 *
 * max_size gives the maximum size of buf. This is filled up with input.
 * We never return less than one character until EOF is reached. Thus, we
 * read more than one true input line if a comment spans over more than one
 * line.
 * A line will either be terminated by a single '\n' or by a blank. The
 * later one replaces a line continuation (',' [spaces] EOL).
 * Errors in this low
 *
 * Conclusion: We have to fight very hard to set the expected line number.
 *             * Comments spanning over lines set them on getting the
 *               "follow" lines.
 *             * Concatenated lines set
 */
static int fill_buffer( char *buf, int max_size )
{
   /* statics protected by regina_parser */
   static char line[BUFFERSIZE+2] ; /* special buffer to allow max_size */
   static int pos = 0, max = 0 ;    /* being smaller than BUFFERSIZE+1  */
   static int nesting = 0;          /* nesting level of comments        */
   int nesting_start_line = 0;      /* start line of comment for errortext() */
   char *dest, c;
   int i, squote, dquote;
   int line_comment;
   FILE *arg;

   if (firstln == 0)
   {
      firstln = 1;
      contline = 0;
      nesting = 0;
      pos = 0;
      if ( !io_handlers.getcHandlerArg ) {
          arg = yyin;
      } else {
          arg = io_handlers.getcHandlerArg;
      }
      max = get_next_line( line, sizeof(line), arg); 
      if (max < 0) /* empty input file */
         return 0 ;
      /* test for both #! - fixes bug 1230639 */
      if ( max > 1
      &&  line[0] == '#'
      &&  line[1] == '!' )
      {  /* Ignore first line beginning this way for unix compat */
         max = 5;
         memcpy( line, "/**/\n", 5 );
      }
   }
   else if (pos < max) /* Are there still characters to transmit? */
   {
      /* Buffer already checked for correctness */
      if (max_size > max - pos)
         max_size = max - pos;
      memcpy(buf, line + pos, max_size);
      pos += max_size;
      return(max_size);
   }
   else /* Need next line */
   {
      if (contline && !nesting)
      {
         extnextline = ++nextline ;
         extnextstart = 1 ;
         contline = 0;
      }
      pos = 0;
      if ( !io_handlers.getcHandlerArg ) {
          arg = yyin;
      } else {
          arg = io_handlers.getcHandlerArg;
      }
      max = get_next_line( line, sizeof(line), arg);
      if (max < 0) /* empty input file */
      {
         if (nesting)
         {
            parser_data.tline = linenr - 1 ; /* set tline for exiterror */
            exiterror( ERR_UNMATCHED_QUOTE, 1 ) ;
            return 0;
         }
         return 0 ;
      }
   }

   /* A new line is available, check first for an ending comment */
   dest = line; /* we change comments in line */
   if (nesting) /* This may lead to more line reading */
   {
      /*
       * The first time extnextline is non-zero, we have the comment
       * starting sequence line. This is saved for use if no matching
       * ending comment sequence is found, so that the error message
       * reflects the start of the comment.
       * Regina feature request: #508788
       */
      if ( extnextline < 0 )
         nesting_start_line = nextline+1;
      extnextline = ++nextline ;
      extnextstart = 1; /* See Reference (*) below */
repeated_nesting:
      while (pos < max)
      {
         c = line[pos];
         if (c == '*') /* start of comment end? */
         {
            if (line[pos+1] == '/')
            {  /* pos+1 always exists, at least '\n' or '\0' */
               if (--nesting == 0)
               {
                  pos += 2;
                  *dest++ = '`';
                  *dest++ = '`';
                  break;
               }
               *dest++ = '`';
               pos++;
            }
         }
         else if (c == '/') /* start of new begin? */
         {
            if (line[pos+1] == '*')
            {
               nesting++;
               *dest++ = '`';
               pos++;
            }
         }
         *dest++ = '`';
         pos++;
      }
      if (pos >= max)
      {
         pos = 0;
         if ( !io_handlers.getcHandlerArg ) {
             arg = yyin;
         } else {
             arg = io_handlers.getcHandlerArg;
         }
         max = get_next_line( line, sizeof(line), arg); 
         if (max < 0) /* empty input file */
         {
            if ( nesting_start_line )
               parser_data.tline = nesting_start_line ; /* set tline for exiterror */
            else
               parser_data.tline = linenr - 1 ; /* set tline for exiterror */
            exiterror( ERR_UNMATCHED_QUOTE, 1 ) ;
            return 0 ;
         }
         /* This is a comment continuation. If the lexer will return
          * something it already has a valid tline/tstart pair.
          * The lexer will return the current token and on the NEXT
          * call it expects a valid nextline/nextstart pair.
          */
         extnextline = ++nextline; extnextstart = 1;
         dest = line; /* we change comments in line */
         goto repeated_nesting;
      }
      extnextstart = pos + 1;
      if (contline)
      { /* Exception! Have a look at: "x='y',{*\n\n*}\n'z'". This should
         * result in "x = 'y' 'z'".
         * We must parse until EOL and check for whitespaces and comments...
         */
         while (pos < max)
         {
            c = line[pos];
            if (!rx_isspace(c))
            {
               if (c == '/')
               {
                  if (line[pos+1] == '*')
                  {
                     pos += 2;
                     nesting++;
                     goto repeated_nesting;
                  }
               }
               parser_data.tline = linenr - 1 ; /* set tline for exiterror */
               exiterror( ERR_YACC_SYNTAX, 1, parser_data.tline ) ; /* standard error */
               return 0;
            }
            pos++;
         }
         /* All done, it was a continuation line. */
         /* contline will be resetted by: */
         return fill_buffer( buf, max_size ) ;
      }
   }
   /* We have something to play with. Run through the input and check for
    * strings including comments.
    */
   squote = dquote = 0;
   line_comment = 0;
   while (pos < max)
   {
      /* We use selective loops to reduce comparisons */
      if (nesting)
         do
         {
            c = line[pos];
            if (c == '*') /* start of comment end? */
            {
               if (line[pos+1] == '/')
               {  /* pos+1 always exists, at least '\n' or '\0' */
                  if (--nesting == 0)
                  {
                     pos += 2;
                     *dest++ = '`';
                     *dest++ = '`';
                     break;
                  }
                  pos++;
               }
            }
            else if (c == '/') /* start of new begin? */
            {
               if (line[pos+1] == '*')
               {
                  nesting++;
                  pos++;
                  *dest++ = '`';
               }
            }
            pos++;
            *dest++ = '`';
         } while (pos < max);
      else if (squote)
         {
            while ((c = line[pos]) != '\'')
            {
               *dest++ = c;
               if (++pos >= max)
               {
                  parser_data.tline = linenr - 1 ; /* set tline for exiterror */
                  exiterror( ERR_UNMATCHED_QUOTE, 2 ) ;
                  return 0;
               }
            }
            *dest++ = '\'';
            pos++;
            squote = 0;
         }
      else if (dquote)
         {
            while ((c = line[pos]) != '\"')
            {
               *dest++ = c;
               if (++pos >= max)
               {
                  parser_data.tline = linenr - 1 ; /* set tline for exiterror */
                  exiterror( ERR_UNMATCHED_QUOTE, 3 ) ;
                  return 0;
               }
            }
            *dest++ = '\"';
            pos++;
            dquote = 0;
         }
      else if (line_comment)
         {
            while ((c = line[pos]) >= ' ')    /* not at end of line yet */
            {
               *dest++ = '`';
               if (++pos >= max)
               {
                  parser_data.tline = linenr - 1 ; /* set tline for exiterror */
                  exiterror( ERR_UNMATCHED_QUOTE, 3 ) ;
                  return 0;
               }
            }
            *dest++ = c;    /* line terminator */
            pos++;
            line_comment = 0;
         }
      else
         while (pos < max)
            switch (c = line[pos])
            {
               case '\'':
                  *dest++ = c ;
                  squote = 1 ;
                  pos++ ;
                  goto outer_loop;

               case '\"':
                  *dest++ = c ;
                  dquote = 1 ;
                  pos++ ;
                  goto outer_loop;

               case '/':
                  if (line[pos + 1] == '*')
                  {
                     *dest++ = '`' ;
                     *dest++ = '`' ;
                     pos += 2 ;
                     nesting++ ;
                     goto outer_loop;
                  }
                  else
                  {
                     *dest++ = c;
                     pos++ ;
                  }
                  break ;

               case '-':    /* line "--" comments */
                  if ( line[pos + 1] == '-'
                  &&   get_options_flag( parser_data.TSD->currlevel, EXT_SINGLE_LINE_COMMENTS )
                  &&   !get_options_flag( parser_data.TSD->currlevel, EXT_STRICT_ANSI ) )
                  {
                     *dest++ = '`' ;
                     *dest++ = '`' ;
                     pos += 2 ;
                     line_comment = 1 ;
                     goto outer_loop;
                  }
                  else
                  {
                     *dest++ = c;
                     pos++ ;
                  }
                  break ;

               case '`':
                  parser_data.tline = linenr - 1 ; /* set tline for exiterror */
                  exiterror( ERR_INVALID_CHAR, 1, c, c ) ;
                  return 0;

               default:
                  *dest++ = c;
                  pos++ ;
            }
outer_loop:
      ;
   }

   max = (int) (dest - line);

   /* Now we can replace a ',' [spaces|comments] '\n' with the line
    * continuation, but check for nesting first
    */
   if (nesting)
   { /* Don't leave ANY spaces at EOL. That would confuse the lexer. */
      i = max - 1;
      while ((i >= 0) && rx_isspace(line[i]))
         i--;
      max = i + 1;
      /* Of course, there is one exception: line continuation */
      while ((i >= 0) && (line[i] == '`'))
         i-- ;
      if ((i >= 0) && (line[i] == ','))
      {
         contline = 1;
         line[i] = ' ';
         max = i + 1;
      }
      /* (Reference (*) )
       * At this point the lexer can't determine the nextline since we eat up
       * the \n. This leads to an incorrect count. But either the '`'-signs
       * are ignored or they are follows of a "token", a valid word.
       * Look at "say x;say y ``". This will cause the lexer to
       * return at least 4 tokens (SAY "x" ";" SAY) before "y" will be
       * returned. We can only set nextline/nextstart at "y".
       * Result: We set this pair at the start of the next call to
       * fill_buffer such that the next call to yylex will set the correct
       * values.
       */
   }
   else
   {
      i = max - 1; /* on last valid char */
      while (i >= 0)
      {
         if (!MY_ISBLANK(line[i]) && (line[i] != '\n'))
            break;
         i--;
      }
      /* i now -1 or on last nonblank */
      if ((i >= 0) && (line[i] == ','))
      {  /* FIXME: What shall be do with "," followed by EOF? */
         max = i + 1;
         line[i] = ' ';
         contline = 1;
      }
   }

   if (max_size > max)
      max_size = max;
   memcpy(buf, line, max_size);
   pos = max_size;
   return(max_size);
}


/* yywrap MAY be called by the lexer is EOF encounters, see (f)lex docu */
int yywrap( void )
{
   ASSERT ( dolevel>= 0 ) ;
   if (do_level>0)
   {
      parser_data.tline = linenr - 1 ; /* set tline for exiterror */
      exiterror( ERR_INCOMPLETE_STRUCT, 0 )  ;
   }
   return 1 ;
}

/******************************************************************************
 ******************************************************************************
 * global interface ***********************************************************
 ******************************************************************************
 *****************************************************************************/

extern FILE *yyin_io;
extern FILE *yyout_io;

/* initalize all local and global values */
static void init_it_all( tsd_t *TSD )
{
#ifdef REXXDEBUG
   fprintf(stderr, "func=%s\n", __FUNCTION__);
#endif

#if defined(FLEX_SCANNER) && defined(FLEX_DEBUG)
   if (__reginadebug)
      yy_flex_debug = 1;
     else
      yy_flex_debug = 0;
#endif
   inEOF = 0 ;
   in_numform = 0 ;
   next_numform = 0 ;
   expression_ended = 0 ;
   insert_abuttal = 0 ;
   obs_with = 0 ;
   in_do = 0 ;
   in_then = 0 ;
   inhibit_delayed_abuttal = 0 ;
   firstln = 0 ;
   in_parse = 0 ;
   in_trace = 0 ;
   itflag = 0 ;
   in_signal = 0 ;
   in_call = 0 ;
   in_address = not_in_address ;
   seek_with = no_seek_with ;
   kill_this_space = 0 ;
   ipretflag = 0 ;
   do_level = 0 ;
   singlequote = 0 ;
   doblequote = 0 ;
   cch = 0 ;
   bufptr = 0 ;
   cchmax = 0 ;
   ch = '\0',
   delayed_symbol = 0,
   contline = 0;
   extnextstart = 0;
   interptr = NULL ;
   interptrmax = NULL ;
                          /* non-zero values */
   linenr = 1 ;
   nextline = 1;
   nextstart = 1;
   kill_next_space = 1 ;
   extnextline = -1 ;
   SymbolDetect = 0;

   memset(&parser_data, 0, sizeof(internal_parser_type));
   parser_data.TSD = TSD;

   if ( !TSD->io_initialized ) {
       if ( !regina_io_handlers_initialized_get() ) {
           regina_default_io_handlers();
       } else {
           if ( io_handlers.checkVerHandler ) {
               io_handlers.checkVerHandler(io_handlers.checkVerHandlerArg, PLUGIN_VERSION_NUMBER);
           } else {
               verify_sync_out();
           }
           if ( io_handlers.outputInitHandler ) {
               io_handlers.outputInitHandler(io_handlers.outputInitArg, 0, 0);
           }
           if ( io_handlers.inputInitHandler ) {
               io_handlers.inputInitHandler(io_handlers.inputInitArg, 0, 0);
           }
       }

       TSD->io_initialized = 1;
   }
}

/* fetch may only be called by fetch_protected. The parser and lexer are
 * already protected by regina_parser by fetch_protected.
 * This function prepares the lexer and parser and call them. The
 * result and all generated values are stored in result. The parser
 * tree isn't executed here.
 * Exactly fptr xor str must be non-null.
 */
static void fetch(tsd_t *TSD, FILE *fptr, const streng *str,
                  internal_parser_type *result)
{
#ifdef REXXDEBUG
   fprintf(stderr, "func=%s\n", __FUNCTION__);
#endif

   init_it_all( TSD ) ;

#ifdef FLEX_SCANNER
   yy_init = 0 ;
   yy_delete_buffer(YY_CURRENT_BUFFER) ;
   yyrestart(fptr) ;
#else
   yysptr = yysbuf ;
   yyin = fptr ;
#endif

   if (str != NULL)
   {
      ipretflag = 1 ;
      cchmax = str->len ;
      interptr = Str_val(str); /*str->value*/ ;
      last_interptr = interptr ;
      interptrmax = interptr + cchmax ;
      parser_data.incore_source = Str_val(str)/*str->value*/; /* fixes bug 972796 */
      result->incore_source = str->value;
   }

   BEGIN comm ;
   NewProg();
   parser_data.result = __reginaparse();

#ifdef FLEX_SCANNER
   yy_delete_buffer(YY_CURRENT_BUFFER) ;
#else
   yysptr = yysbuf ;
#endif
   yyin = NULL ;

   *result = parser_data;
   /* Some functions assume null values if parsing isn't running: */
   memset(&parser_data, 0, sizeof(internal_parser_type));
}

/* This function serializes the parser/lexer requests of the process and
 * call fetch which will make the work. Look there.
 */
static void fetch_protected( tsd_t * volatile TSD, FILE *fptr,
                             const streng *str, internal_parser_type *result )
{
   volatile int panicked = 0;
   tsd_t * volatile saved_TSD;
   int j_ret;

#ifdef REXXDEBUG
   fprintf(stderr, "func=%s\n", __FUNCTION__);
#endif

   THREAD_PROTECT( regina_parser )
   TSD->in_protected = 1;
   memset(&parser_data, 0, sizeof(internal_parser_type));

   saved_TSD = TSD; /* vars used until here */
   j_ret = setjmp( TSD->protect_return );
   if ( j_ret == 1 )
   {
      TSD = saved_TSD; /* prevents bugs like  592393 */
      panicked = 1;
   } else if ( j_ret == 2 ) {
       /*
        * This allows restarting parsing when an error is encountered
        * which would otherwise cause a termination, i.e. in batch mode
        */
       goto interactive_goto;
   } else {
      fetch( TSD, fptr, str, result );
   }

interactive_goto:
   TSD->in_protected = 0;
   THREAD_UNPROTECT( regina_parser )

   if ( j_ret == 2 ) {
      longjmp( TSD->interactive_return, 1 );
   }

   if ( !panicked )
      return;

   /*
    * We got a fatal condition while fetching the input.
    */
   memset(result, 0, sizeof(internal_parser_type));

   /*
    * FIXME: Currently no time to investigate it, but we have to do
    *        a cleanup of the node and source lines of parser_data
    *        here. Test this with
    *        interpret '"a='
    *        and with
    *        interpret 'nop;"a='
    */
   if ( TSD->delayed_error_type == PROTECTED_DelayedInterpreterExit )
      jump_interpreter_exit( TSD, TSD->expected_exit_error );
   if ( TSD->delayed_error_type == PROTECTED_DelayedRexxSignal )
      jump_rexx_signal( TSD );
   jump_script_exit( TSD, TSD->systeminfo->result );
}

/* fetch_file reads in a REXX file from disk (or a pipe). It returns without
 * executing the program. The parsed tree with all needed values including
 * the result of the parsing is copied to result.
 * fptr remains open after this call.
 * type is either PARSE_ONLY or PARSE_AND_TIN. In the later case a tinned variant of the
 * parsing tree is created, too.
 */
void fetch_file(tsd_t *TSD, FILE *fptr, internal_parser_type *result)
{
#ifdef REXXDEBUG
   fprintf(stderr, "func=%s\n", __FUNCTION__);
#endif
   fetch_protected(TSD, fptr, NULL, result);
}

/* fetch_string reads in a REXX macro from a streng. It returns without
 * executing the program. The parsed tree with all needed values including
 * the result of the parsing is copied to result.
 * type is either PARSE_ONLY or PARSE_AND_TIN. In the later case a tinned variant of the
 * parsing tree is created, too.
 * The function is typically called by an "INTERPRET" instruction.
 */
void fetch_string(tsd_t *TSD, const streng *str, internal_parser_type *result)
{
#ifdef REXXDEBUG
   fprintf(stderr, "func=%s\n", __FUNCTION__);
#endif
   fetch_protected(TSD, NULL, str, result);
}

